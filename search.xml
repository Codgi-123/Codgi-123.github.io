<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VMware中虚拟机共享主机SSR</title>
      <link href="article/vm_ssr/"/>
      <url>article/vm_ssr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所使用环境:  </p><ol><li>VMware Workstation 16 Pro 版本号：16.1.0 build-17198959</li><li>Ubuntu 18.04.1 、Kali-linux-2020.4</li><li>ShadowsocksR for Windows 5.1.6</li><li>Win10 20H2</li></ol></blockquote><h2 id="Ubuntu-18-04-1-下配置"><a href="#Ubuntu-18-04-1-下配置" class="headerlink" title="Ubuntu 18.04.1 下配置"></a>Ubuntu 18.04.1 下配置</h2><h3 id="Step1-找到虚拟机与主机网络的连接方式"><a href="#Step1-找到虚拟机与主机网络的连接方式" class="headerlink" title="Step1. 找到虚拟机与主机网络的连接方式"></a>Step1. 找到虚拟机与主机网络的连接方式</h3><p>记住是 <code>桥接</code> or <code>NAT</code>，鼠标放到右下角看下即可，如图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/s6tJOJ.png" width="40%"></div><h3 id="Step2-设置SSR本地代理"><a href="#Step2-设置SSR本地代理" class="headerlink" title="Step2. 设置SSR本地代理"></a>Step2. 设置SSR本地代理</h3><p>如下图，本地端口选择没有占用的，并记住端口号：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/s6UTds.png" width="45%"></div><h3 id="Step3-查看VMware的IPv4地址"><a href="#Step3-查看VMware的IPv4地址" class="headerlink" title="Step3. 查看VMware的IPv4地址"></a>Step3. 查看VMware的IPv4地址</h3><p>在主机上执行 <code>ipconfig</code> 找到 <code>VMware Network Adapter VMnet1</code> 或者 <code>VMware Network Adapter VMnet8</code>  </p><ul><li><p>如果是 <code>桥接模式</code> ： 找到 <code>VMware Network Adapter VMnet1</code> 下的IPv4地址，如图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/s6wnPI.png" width="55%"></div></li><li><p>如果是 <code>NAT</code> ：找到 <code>VMware Network Adapter VMnet8</code> 下的IPv4地址，如图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/s6wNin.png" width="55%"></div></li></ul><h3 id="Step4-在虚拟机中设置代理"><a href="#Step4-在虚拟机中设置代理" class="headerlink" title="Step4. 在虚拟机中设置代理"></a>Step4. 在虚拟机中设置代理</h3><p>转到 <code>设置</code> — <code>网络</code> — <code>网络代理</code>，将方式设置为手动，代理地址填写对应网络模式下的IPv4地址。  </p><ul><li>使用 <code>NAT</code> 方式，填写 <code>VMware Network Adapter VMnet8</code> 下的IPv4地址</li><li>使用 <code>桥接</code> 方式，填写 <code>VMware Network Adapter VMnet1</code> 下的IPv4地址</li></ul><p>如下图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/s60ElV.png" width="45%"></div><h3 id="然后就可以愉快地在虚拟机中使用主机的SSR了"><a href="#然后就可以愉快地在虚拟机中使用主机的SSR了" class="headerlink" title="然后就可以愉快地在虚拟机中使用主机的SSR了~"></a>然后就可以愉快地在虚拟机中使用主机的SSR了~</h3><p>见下图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/s60Wkj.png" width="85%"></div><hr><h2 id="Kali-linux-2020-4-下配置"><a href="#Kali-linux-2020-4-下配置" class="headerlink" title="Kali-linux-2020.4 下配置"></a>Kali-linux-2020.4 下配置</h2><h3 id="卸载掉原来自带的-proxychains"><a href="#卸载掉原来自带的-proxychains" class="headerlink" title="卸载掉原来自带的 proxychains"></a>卸载掉原来自带的 <code>proxychains</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get autoremove proxychains</span><br></pre></td></tr></table></figure><p>删除 <code>proxychians.conf</code> 配置文件:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /ect/</span><br><span class="line"></span><br><span class="line">rm -rf proxychains.conf</span><br></pre></td></tr></table></figure></p><h3 id="下载并安装-proxychains-ng"><a href="#下载并安装-proxychains-ng" class="headerlink" title="下载并安装 proxychains-ng"></a>下载并安装 <code>proxychains-ng</code></h3><p>下载源码：<code>git clone https://github.com/rofl0r/proxychains-ng.git</code><br>编译安装：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd proxychains-ng/</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">make install-config</span><br></pre></td></tr></table></figure></p><h3 id="配置-proxychains"><a href="#配置-proxychains" class="headerlink" title="配置 proxychains"></a>配置 <code>proxychains</code></h3><p>修改 <code>proxychains</code> 配置文件。默认路径是 <code>/etc/proxychains.conf</code>  </p><p>修改文末的 <code>[ProxyList]</code>，如下图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/scGfPK.png" width="50%"></div><ul><li>其中SSR使用的是 <code>SOCKS5</code> 协议</li><li><p>地址填写主机IPv4地址，使用 <code>ipconfig</code> 在本机上查看，如下图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/18/scGoKH.png" width="60%"></div></li><li><p>端口号获取见本文 <code>Ubuntu 18.04.1 下配置</code> 中 <code>Step2. 设置SSR本地代理</code></p></li></ul><h3 id="使用-proxychains"><a href="#使用-proxychains" class="headerlink" title="使用 proxychains"></a>使用 <code>proxychains</code></h3><p>首先测试一下代理是否成功：<code>proxychains4 curl myip.ipip.net</code></p><p>使用代理打开FireFox： <code>proxychains4 firefox</code></p><div align=center><img src="https://s3.ax1x.com/2021/01/18/scJVRU.png" width="60%"></div><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><ol><li>备份原来的文件：<code>/etc/apt/sources.list</code><br>使用命令：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></li><li><p>前往 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源镜像站</a></p><p> 选择适合的版本，这里我是20.04就选择对应的，如图：</p></li></ol><div align=center><img src="https://s3.ax1x.com/2021/01/18/scJ0ot.png" width="60%"></div><ol><li><p>根据需要记录其中的软件源，将其填入 <code>sources.list</code> 中<br> 使用：<code>sudo vim /etc/apt/sources.list</code> ，将复制的软件源填入</p></li><li><p>更新源<br><code>sudo apt-get update &amp;&amp; apt-get upgrade</code></p></li></ol><h4 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h4><ol><li><p>备份原来的文件：<code>/etc/apt/sources.list</code><br>使用命令：<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></p></li><li><p>在 <code>sources.list</code> 中结尾添加以下任意更新源</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中科大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">清华大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">浙大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">东软大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</span><br><span class="line"></span><br><span class="line">官方源</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">重庆大学</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>更新源 <code>sudo apt-get update &amp;&amp; apt-get upgrade</code></li></ol><h3 id="安装Google中文输入法"><a href="#安装Google中文输入法" class="headerlink" title="安装Google中文输入法"></a>安装Google中文输入法</h3><ol><li>安装fcitx<br> 命令： <code>apt-get install fcitx</code></li><li>安装Google拼音输入法<br> 命令： <code>apt-get install fcitx-googlepinyin</code></li><li>重启系统<br> 命令： <code>reboot</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github上Fork后与原仓库同步</title>
      <link href="article/update_fork/"/>
      <url>article/update_fork/</url>
      
        <content type="html"><![CDATA[<h2 id="有一个很省事的方法"><a href="#有一个很省事的方法" class="headerlink" title="有一个很省事的方法"></a>有一个很省事的方法</h2><blockquote><p>如果你 <code>Fork</code> 后对原仓库的代码修改量不大，基本上只修改了一些参数的话<br>直接前往 <code>Fork</code> 仓库的 <code>Settings</code> 页面，翻到最下面然后<code>Delete</code> 吧<br>然后重新 <code>Fork</code> 一遍原仓库，在新 <code>Fork</code> 的仓库中重新修改</p></blockquote><p>不得不说这种方法很省事，但是这种方法应该作为最后的选择，而不是首选</p><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>上次和小伙伴门一起写项目的时候也经常要用到 <code>Merge</code> ，不怎么熟练那就多练练(手动摸稽稽</p><ul><li><p>Step1. 进入本地仓库的目录<br>这里指的<strong>本地仓库</strong>是在电脑上 <code>Clone</code> 的自己的仓库</p></li><li><p>Step2. 查看远程仓库的路径<br>使用 <code>git remote -v</code>，一般来说只有两条记录  </p><div align=center><img src="https://s3.ax1x.com/2021/01/16/sDkw9g.png" ></div>  <p>说明当前的仓库没有设置 <code>upstream</code> (上游代码库)，设置一次 <code>upstream</code> 后就无需重复设置了</p></li><li><p>Step3. 设置上游代码库<br>使用 <code>git remote add upstream 上游代码库</code>  </p><p>这个命令执行后，没有任何返回信息  </p><div align=center><img src="https://s3.ax1x.com/2021/01/16/sDkvgH.png" width="84%"></div><p>所以再次执行命令 <code>git remote -v</code> 检查是否成功  </p><div align=center><img src="https://s3.ax1x.com/2021/01/16/sDkL4O.png " width="84%"></div></li><li><p>Step4. 检查本地是否有未提交的修改<br>使用 <code>git status</code> 查看  </p><blockquote><p>如果有，则把本地的有效修改推送到你的github仓库<br><code>git add .</code> 或者 <code>git add filename</code><br><code>git commit -m &quot;update&quot;</code><br><code>git push origin master</code><br>最后再执行一次 <code>git status</code> 检查本地已无未提交的修改</p></blockquote></li><li><p>Step5. 抓取原仓库的更新<br>使用 <code>git fetch upstream</code>  </p><div align=center><img src="https://s3.ax1x.com/2021/01/16/sDArGD.png " width="84%"></div></li><li><p>Step6. 切换到主分支<br><em>注: 我所使用的仓库主分支名为</em> <code>main</code>  </p><p>使用 <code>git checkout main</code></p><div align=center><img src="https://s3.ax1x.com/2021/01/16/sDESWF.png " width="84%"></div></li><li><p>Step7. 合并远程的主分支<br>使用 <code>git merge upstream/main</code>  </p><div align=center><img src="https://s3.ax1x.com/2021/01/16/sDEiLR.png " width="84%"></div><ol><li><p><strong>如果没有自动合并出错则进入Step8</strong></p></li><li><p>这里看到输出信息里面有自动合并出错，需要手动 <code>Merge</code> 的文件在倒数第二行指出<br>使用 VS Code 打开本地仓库的该文件就能看到手动 <code>Merge</code> 选择，选择你想要的方式：<br><code>使用传入方案</code>(也就是原仓库的代码) 或者是 <code>保留本地方案</code>(这个就是你修改的东西)<br>我们肯定就选择第二种了</p><ul><li>合并冲突后需要 <code>git add .</code> 或者 <code>git add 手动合并的文件名</code></li><li><code>git commit -m &quot;merged&quot;</code></li></ul></li></ol></li></ul><ul><li>Step8. 推送本地代码到自己的云端仓库<br>使用<code>git push</code></li></ul><p>已经就解决了 <code>fork</code> 的仓库和原仓库版本不一致的问题啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat Premium 15 破解激活</title>
      <link href="article/navicat/"/>
      <url>article/navicat/</url>
      
        <content type="html"><![CDATA[<p>最近在学习数据库SQL方面的知识，需要用到一个MYSQL管理软件(Navicat for MySQL)，去官网下载的时候发现了还有一个更强大的 Navicat Premium 15，结果就是懂得都懂了(斜眼笑<br><a id="more"></a></p><h2 id="00"><a href="#00" class="headerlink" title="#00"></a>#00</h2><p>先去Navicat的官网下载并安装<a href="https://www.navicat.com.cn/products/navicat-premium">Navicat Premium</a></p><p>下图是Navicat Premium的界面：</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJy4K0.png" width="80%" height="80%"></div><h2 id="01使用破解工具"><a href="#01使用破解工具" class="headerlink" title="#01使用破解工具"></a>#01使用破解工具</h2><p><a href="https://wws.lanzous.com/izsNkkb8i3a">点我下载破解工具</a> 密码:265e</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><strong>把你网给我断了</strong>  </p><p><strong>把你网给我断了</strong>  </p><p><strong>把你网给我断了</strong></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p><strong>退出所有的杀毒软件后打开破解工具</strong>  </p><p>下图为注册机的主界面：</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJcfBV.png" width="80%" height="80%"></div><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><ul><li><ol><li><p>在主页面的第一个选项 <code>1) Patch)</code> 里选择 <code>Backup</code>，<code>Host</code>，<code>Navicat</code> 是哪个版本就选哪个，这里选择Navicat V 15，然后点击这一行最右边的 <code>Patch</code> 按钮，如下图所示</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJ2fFU.png" width="70%"></div></li><li><p>在弹出的新窗口中找到 <code>Navicat</code> 的安装位置，选中文件夹中的 <code>navicat.exe</code> 文件，出现下图所示的对话框就说明第一步正确了</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJ2VMR.png" width="35%"></div></li></ol></li><li><p>主页面中第二栏： <code>2) License. Product and Language</code> 中保持默认选择就行</p><p>  <code>License</code> 里选中 <code>Enterprise</code>,<code>Produce</code> 里选择 <code>Premium</code> 、<code>Languages</code>里选择 <code>Simplified Chinese(简体中文)</code></p><p>  如下图所示：</p>  <div align=center><img src="https://s3.ax1x.com/2021/01/12/sJR3kT.png"></div></li><li><p>主页中第三栏： <code>3) Resale License</code> 中 <code>Resale Versions</code> 选择 <code>Site license</code> , 如下图所示：</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJRhHP.png"></div></li><li><p><strong>重要！最后一步！第四栏 <code>4) Keygen / Offline Activation</code>中</strong>  </p><ol><li><p>最顶部这一栏</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJWZE6.png"></div>  <p>直接点击 <code>Generate</code>，会在左侧的 <code>Serial Keygen</code> 中产生一段序列号，复制该序列号，马上用到</p></li><li><p>打开Navicat Premium 15，点击注册按钮  </p><p>   将刚刚拿到的序列号复制进左侧中，然后点击确定</p><p>   稍等一会后会弹出提示： <em>激活服务器不可用……</em> ，在对话框中点击手动激活</p><p>   Navicat Premium 15会打开一个新的窗口，给你一大段请求码，复制请求码</p></li><li><p>回到注册机中，将刚刚拿到的请求码复制进这一个框中，如图：</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJflJU.png"></div></li><li><p>在下图中：</p><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJfsQH.png"></div><p>点击左侧的 <code>Generate</code>，生成对应的激活码，并复制激活码</p><ol><li>回到Navicat Premium 15的刚刚的激活界面，在请求码框下面的激活码框内填入刚刚复制的激活码，点击激活</li></ol></li></ol></li></ul><h2 id="02破解成功"><a href="#02破解成功" class="headerlink" title="#02破解成功"></a>#02破解成功</h2><div align=center><img src="https://s3.ax1x.com/2021/01/12/sJhMnA.png" width="50%"></div><h2 id="03后话"><a href="#03后话" class="headerlink" title="#03后话"></a>#03后话</h2><p>如果经济允许，还是希望可以支持正版！！！</p><p>附上购买地址 <a href="http://www.navicat.com.cn/store/navicat-premium-plan">http://www.navicat.com.cn/store/navicat-premium-plan</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小屋开启PWA了</title>
      <link href="article/offline_view/"/>
      <url>article/offline_view/</url>
      
        <content type="html"><![CDATA[<p>这两天闲来无事，想着有时候理想也能康康上面的博客，把之前想弄的PWA加上了，这篇偷个懒写一下<br><a id="more"></a></p><ul><li>主题使用 <a href="https://molunerfinn.com/">melody</a>，<a href="https://molunerfinn.com/hexo-theme-melody-doc">文档在这儿</a></li></ul><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p><a href="https://web.dev/what-are-pwas/">什么是PWA</a><br>总结一下就是这些：</p><ol><li>渐进式</li><li>自适应</li><li>连接无关性</li><li>类似应用</li><li>持续更新</li><li>安全</li><li>可发现</li><li>可再互动</li><li>可安装</li><li>可连接</li></ol><h3 id="其实说白了就是"><a href="#其实说白了就是" class="headerlink" title="其实说白了就是"></a>其实说白了就是</h3><p>本站现在访问一次过后可以离线访问啦  </p><p>但是我不知道为啥有几个页面访问不了  </p><p>还有文章里面有图片别问我离线为啥访问不了  </p><p><strong>就这样吧这篇，我要去复习了</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="article/ds-sort/"/>
      <url>article/ds-sort/</url>
      
        <content type="html"><![CDATA[<p>这么感觉我都忘了<br><a id="more"></a></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><strong>关于时间复杂度：</strong></p><ul><li>平方阶 $(O(n^2))$ 排序 各类简单排序：<code>直接插入</code>、<code>直接选择</code>和<code>冒泡排序</code>。</li><li>线性对数阶 $(O(n log2n))$ 排序: <code>快速排序</code>、<code>堆排序</code> 和 <code>归并排序</code>；</li><li>$O(n1+§))$ 排序，(§ 是介于 0 和 1 之间的常数): <code>希尔排序</code></li><li>线性阶 $(O(n))$ 排序: <code>基数排序</code>，此外还有<code>桶</code>、<code>箱排序</code>。</li></ul><p><strong>关于稳定性：</strong></p><ul><li><p><strong>稳定的排序算法</strong>：冒泡排序、插入排序、归并排序和基数排序。</p></li><li><p><strong>不是稳定的排序算法</strong>：选择排序、快速排序、希尔排序、堆排序。</p></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单直观的排序算法。重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><div align=center><img src="https://s3.ax1x.com/2020/12/17/r812yd.gif" style="height:50%; "></div><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>什么时候最快<br>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p></li><li><p>什么时候最慢<br>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><div align=center><img src="https://s3.ax1x.com/2020/12/17/r83M1e.gif" style="height:50%; "></div><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将<strong>待插入元素插入到相等元素的后面</strong>）</p></li></ol><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><div align=center><img src="https://s3.ax1x.com/2020/12/17/r896xg.gif" style="width:80%;"></div><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种更高效的改进版本。但希尔排序是<strong>非稳定排序算法</strong></p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p><strong>希尔排序的基本思想：</strong>  </p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><div align=center><img src="https://s3.ax1x.com/2020/12/17/r8C9zD.gif" style="height:50%; "></div><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ol><li><strong>原始数组</strong>：<code>8，9，1，7，2，3，4，5，6，0</code>  </li><li><strong>初始增量</strong>：<code>length/2=5</code>，意味整个数组被分成5组，分别为<code>[8,3]</code> <code>[9,5]</code> <code>[1,4]</code> <code>[7,6]</code> <code>[2,0]</code></li><li><strong>进行直接插入排序</strong>：结果为：<code>3,5,1,6,0,8,9,4,7,2</code></li><li><strong>缩小增量</strong>： <code>length/2/2=2</code>，整个数组被分成两组，分别为<code>[3,1,0,9,7]</code> <code>[5,6,8,4,2]</code></li><li><strong>再进行直接插入排序</strong>: 结果为：<code>0,2,1,4,3,5,7,6,9,8</code></li><li><strong>继续缩小增量</strong>： 达到最小增量<code>1</code>，再进行一次插入排序就可以得到有序数组</li></ol><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法</p><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p><strong>分而治之</strong>  </p><ol><li>假设现在有一组数：<code>[8，4，5，7，1，3，6，2]</code></li><li>先将这一组数按照对半分的思想，分成<code>[8,4,5,7]</code>,<code>[1,3,6,2]</code> 两组</li><li>继续对分成 <code>[8,4]</code>,<code>[5,7]</code>,<code>[1,3]</code>,<code>[6,2]</code></li><li>继续分成单个的数</li></ol><p>上面已经将这组数“分”开，然后再“治”</p><ol><li>两两比较，排序</li><li><code>[4,8]</code>,<code>[5,7]</code>,<code>[1,3]</code>,<code>[2,6]</code></li><li><code>[4,5,7,8]</code>,<code>[1,2,3,6]</code></li><li><code>[1,2,3,4,5,6,7,8]</code></li></ol><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><div align=center><img src="https://s3.ax1x.com/2020/12/17/r8380I.gif" style="height:30%; "></div><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序应该算是在冒泡排序基础上的递归分治法  </p><p>在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来</p><h4 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><div align=center><img src="https://s3.ax1x.com/2020/12/17/r88tbR.gif" style="height:30%; "></div>]]></content>
      
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java复习</title>
      <link href="article/java-priview/"/>
      <url>article/java-priview/</url>
      
        <content type="html"><![CDATA[<p>菜鸡的Java复习<br><a id="more"></a></p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><strong>Java基础</strong></h2><ul><li><code>Java SE(Standard Edition)</code> 标准版本。<br><code>Java EE (Enterprise Edition)</code> 企业版本<br><code>Java ME(Micro Edition)</code> 微型版本。</li></ul><ul><li><p>常用概念</p><ul><li>JDK：Java开发工具包</li><li>JVM：Java虚拟机</li><li>JRE：Java运行环境</li></ul></li><li><p>JDK目录构成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk1.8.0</span><br><span class="line">      |-bin</span><br><span class="line">         |- java.exe</span><br><span class="line">         |- javac.exe</span><br><span class="line">         |- javap.exe</span><br><span class="line">         |- javah.exe</span><br><span class="line">         |- javadoc.exe</span><br><span class="line">      |-lib</span><br><span class="line">         |- tools.jar</span><br><span class="line">         |- dt.jar</span><br><span class="line">      |-jre</span><br><span class="line">         |- bin</span><br><span class="line">             |- java.exe</span><br><span class="line">             |- java.dll</span><br><span class="line">             |- awt.dll</span><br><span class="line">             |- server</span><br><span class="line">                  |- jvm.dll</span><br><span class="line">         |- lib</span><br><span class="line">             |-rt.jar</span><br><span class="line">             |-ext</span><br><span class="line">             |-security</span><br></pre></td></tr></table></figure></li><li>编译、执行命令<ul><li><code>javac xxx.java</code></li><li><code>java 类名(不加任何后缀)</code></li></ul></li></ul><hr><h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a><strong>Java语言基础</strong></h2><h3 id="标识符定义规则"><a href="#标识符定义规则" class="headerlink" title="标识符定义规则"></a>标识符定义规则</h3><ol><li><p>标识符由26个英文字符大小写（a~z，A~Z）、数字(0~9)、下划线(_)和美元符号($)组成。</p></li><li><p>不能以数字开头，不能是关键字</p></li><li><p>严格区分大小写</p></li><li><p>标识符的可以为任意长度</p></li><li><p>包名 多个单词组成时所有字母小写</p></li><li><p>类名和接口 多个单词组成时所有单词的首字母大写</p></li><li><p>变量名和函数名 多个单词组成时第一个单词首字母小写，其他单词首字母大写</p></li><li><p>常量名 多个单词组成时，字母全部大写，多个单词之间使用_分隔</p></li><li><p>虽然Java取消了goto,const这些关键字，但不能用来作为标识符使用</p><h3 id="整性"><a href="#整性" class="headerlink" title="整性"></a>整性</h3></li></ol><ul><li><p><code>byte:</code> 一个字节、8位，取值范围：$-127 \sim 128$,默认值是 <code>0</code></p></li><li><p><code>short:</code> 两个字节、16位，取值范围：$-32768 \sim 32767$,默认值是 <code>0</code></p></li><li><p><code>int:</code> 四个字节、32位，取值范围：$-2^{31} \sim 2^{31}$-1,默认值是 <code>0</code></p></li><li><p><code>long:</code> 八个字节、64位，取值范围：$-2^{63}\sim 2^{63}$-1，默认值是 <code>0L</code><br><strong>如果整性后没有字母默认是<code>int</code></strong></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3></li><li><p><code>float:</code> 单精度型，四个字节，32位，默认值是 <code>0.0f</code></p></li><li><p><code>double:</code> 双精度型，八个字节，64位，默认值是 <code>0.0d</code><br><strong>如果浮点数后没有字母，默认是<code>double</code></strong></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3></li><li><p><code>char:</code> 两个字节、16位，取值范围：<strong>0~65535</strong>  </p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3></li><li><p><code>boolen</code> 一个字节，8位，默认值是<code>false</code></p><h3 id="基本数据类型相互转换"><a href="#基本数据类型相互转换" class="headerlink" title="基本数据类型相互转换"></a>基本数据类型相互转换</h3></li><li><p><code>byte short char</code> 进行运算时转换成 <code>int</code></p></li><li><p>其余情况转换成字节占用最高的</p><h3 id="Java结构化语句"><a href="#Java结构化语句" class="headerlink" title="Java结构化语句"></a><strong>Java结构化语句</strong></h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4></li><li><p><code>switch(expression)</code>语句中，<code>expression</code>的数据类型只能是<code>byte short char int</code></p></li><li><p><code>switch</code> 结构中，每一个<code>case</code>后必须跟上<code>break</code>，否则会继续执行后面的<code>case</code>语句，直到遇到<code>break</code>或者<code>switch</code>结束</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4></li><li><p><code>for</code>类型循环多用于数值型循环</p></li><li><p><code>break</code>语句可以用在循环体或者<code>switch</code>语句中，表示跳出当前循环体或者<code>switch</code></p></li></ul><hr><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><ul><li><p>Java是一门<strong>面向对象</strong>编程语言，Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是<strong>解释型</strong>的</p><h3 id="面向对象编程的三大特性"><a href="#面向对象编程的三大特性" class="headerlink" title="面向对象编程的三大特性"></a>面向对象编程的三大特性</h3><ul><li>封装、继承、多态</li></ul><h3 id="对象和类的关系"><a href="#对象和类的关系" class="headerlink" title="对象和类的关系"></a>对象和类的关系</h3><ul><li>类是对象的抽象，对象是类的实例化</li></ul><h3 id="类的定义（属性、构造方法、方法）"><a href="#类的定义（属性、构造方法、方法）" class="headerlink" title="类的定义（属性、构造方法、方法）"></a>类的定义（属性、构造方法、方法）</h3><p>  <strong>类的定义需要使用<code>class</code>关键字，可能还会指定继承自某一个类，或者需要实现某些接口</strong></p><ul><li><p><strong>一个类可以包含如下变量</strong></p><ul><li><p><strong>类变量</strong><br>类变量也声明在类中，方法体之外，但必须声明为 static 类型</p></li><li><p><strong>成员变量(属性)</strong>  </p><ul><li><p>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。  </p></li><li><p>属性不仅可以使简单类型变量，也可以是一个对象</p></li><li><p>成员变量可以被类中方法、构造方法和特定类的语句块访问。</p></li></ul></li><li><p><strong>局部变量</strong><br>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。  </p><p><strong>所有的变量在使用前都必须进行初始化,方法中的变量必须显示初始化。</strong></p></li></ul></li><li><p><strong>构造方法</strong><br>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。  </p><ul><li>构造方法名与类名相同</li><li><strong>构造方法没有返回值</strong></li><li>在创建新对象时，系统自动的调用该类的构造方法</li><li>一个类可以有多个构造方法</li><li>如果显示定义了任意一个构造方法，那么默认的无参构造方法不会生成</li></ul></li><li><p><strong>方法</strong><br><strong>方法是语句的集合，它们在一起执行一个功能。</strong><br>方法包括<code>修饰符、返回值类型、方法名、参数类型、方法体</code></p></li></ul><h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p><code>new</code>创建一个对象<code>S</code>时进行的步骤：</p><ol><li>加载<code>.class</code>文件</li><li>在栈内存为<code>S</code>申请空间</li><li>在堆内存为对象申请空间</li><li>对成员变量进行默认初始化</li><li>对成员变量进行显示初始化</li><li>执行构造方法</li></ol><h3 id="this-和-super"><a href="#this-和-super" class="headerlink" title="this 和 super"></a><code>this</code> 和 <code>super</code></h3><ul><li><p><code>this</code>是自身的一个对象，代表对象本身，可以理解为指向自己的一个指针</p></li><li><p><code>super</code>可以理解为是指向自己超（父）类对象的一个指针，指的是离自己最近的一个父类</p></li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h3><ul><li>创建一块静态内存区，在静态内存区为静态属性分配空间</li><li>当JVM加载类时，就会执行<h4 id="static的使用方法"><a href="#static的使用方法" class="headerlink" title="static的使用方法"></a><code>static</code>的使用方法</h4></li><li>如果想在不创建对象的情况下调用某个方法，则可以通过将这个方法设置为static来实现。</li><li>在静态方法中不可以使用this关键字</li><li>静态方法可以直接通过类名调用，任何的实例也都可以调用</li><li>不能直接访问所属类的实例变量和实例方法</li></ul><h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>  <img src="https://s3.ax1x.com/2020/12/15/rMi7kT.png" alt="访问控制"></p><h3 id="继承的意义和使用方法"><a href="#继承的意义和使用方法" class="headerlink" title="继承的意义和使用方法"></a>继承的意义和使用方法</h3><p><strong>Java中类之间只允许单一继承</strong>  </p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ol><li>在 Java 中通过 <code>extends</code> 关键字可以申明一个类是从另外一个类继承而来的，<code>extends</code> 只能继承一个类，一般形式如  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>或者使用<code>implements</code>关键字，让当前类继承某个或多个接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通过内部类间接实现多继承</strong><br>如果父类为抽象类或者具体类，那么就仅能通过内部类来实现多重继承，见下  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">str</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">can</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Father_1</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">str</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.str() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mother_1</span> <span class="keyword">extends</span>  <span class="title">Mother</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">can</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.can() - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Father_1().str();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getcan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Mother_1().can();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Son son = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println( son.get());</span><br><span class="line">    System.out.println( son.getcan());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h4><div align=center><img src="https://s3.ax1x.com/2020/12/15/rKOFpV.png" width="80%" height="80%"></div></li></ol><p><em>注：上图中所描述的不支持多继承指的的类之间</em></p><h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul><li><p>子类拥有父类非 <code>private</code> 的属性、方法</p></li><li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</p></li><li>子类可以用自己的方式实现父类的方法</li><li>提高了类之间的耦合性(耦合度高就会造成代码之间的联系越紧密，代码独立性越差)</li><li>当一个类没有继承的两个关键字<code>extends</code>或<code>implements</code>时，则默认继承<code>object</code></li></ul><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态：同一个行为具有多个不同表现形式或形态的能力</p><ul><li>多态存在的三个必要条件<ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<code>Parent p = new Child();</code></li></ul></li></ul><h3 id="final和abstract"><a href="#final和abstract" class="headerlink" title="final和abstract"></a><code>final</code>和<code>abstract</code></h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a><code>final</code></h4><p>  <code>final</code> 修饰类则表示这个类是无法被继承的类, 也就是在类族树中最底层的类,  如果你不想该类被派生出子类, 那么可以用final 来修饰这个类  </p><ul><li><code>private</code> 方法会被认为是<code>final</code>方法</li><li><code>final</code> 变量必须赋值</li><li><code>final</code> 修饰符通常和 <code>static</code> 修饰符一起使用来创建类常量。</li></ul><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a><code>abstract</code></h4><p>  abstract 的中文意思是抽象的, 就是这个东西不存在, 也就是不能被直接实例化  </p><ul><li><code>abstract</code> 可以修饰类，类的方法</li><li>和<code>abstract</code> 有冲突的不能共存的修饰符: <code>private</code> <code>final</code>  <code>static</code> </li></ul><h5 id="abstract-修饰类"><a href="#abstract-修饰类" class="headerlink" title="abstract 修饰类"></a><code>abstract</code> 修饰类</h5><ul><li>抽象类不能直接实例化</li><li>类中如果有一个或多个abstract方法，则该类必须声明为abstract</li><li>抽象类中的方法不一定都是abstract方法，它还可以包含一个或者多个具体的方法</li><li>抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用</li><li>如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类</li></ul><h5 id="abstract-修饰类方法"><a href="#abstract-修饰类方法" class="headerlink" title="abstract 修饰类方法"></a><code>abstract</code> 修饰类方法</h5><ul><li>抽象方法不能包含函数体, 而且要用分号结尾</li><li>不能用private 修饰抽象方法</li><li>不能用static 修饰抽象方法</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>  是抽象方法的集合，接口通常以<code>interface</code>来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法</p><h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>  当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure><p>  <strong>比如：</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;<span class="comment">//接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;<span class="comment">//实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">    m.eat();</span><br><span class="line">    m.travel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong>  </p><ul><li><p>重写接口中声明的方法时：</p><ul><li>重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法</li></ul></li><li><p>实现接口时</p><ul><li>一个类可以同时实现多个接口</li></ul></li></ul><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>  一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用  <code>extends</code> 关键字，子接口继承父接口的方法。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfPeriod</span><span class="params">(<span class="keyword">int</span> period)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overtimePeriod</span><span class="params">(<span class="keyword">int</span> ot)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h4><p>  在Java中，类的多继承是不合法，但接口允许多继承。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span>, <span class="title">Event</span></span></span><br></pre></td></tr></table></figure><h3 id="Java-包-package"><a href="#Java-包-package" class="headerlink" title="Java 包(package)"></a>Java 包(package)</h3><p>Java 使用包<code>package</code>这种机制是为了防止命名冲突，访问控制，提供搜索和定位类<code>class</code>、接口、枚举<code>enumerations</code>和注释<code>annotation</code>等。  </p><h4 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[．pkg2[．pkg3…]];</span><br></pre></td></tr></table></figure><h4 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h4><p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用 <code>import</code>可完成此功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2…].(classname|*);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="Sting类"><a href="#Sting类" class="headerlink" title="Sting类"></a>Sting类</h3><h4 id="创建String字符串"><a href="#创建String字符串" class="headerlink" title="创建String字符串"></a>创建String字符串</h4><ol><li>最简单创建字符串的方式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Codgi&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>利用构造函数创建字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> string(<span class="string">&quot;Codgi&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：如果是采用直接创建的方法，则存储空间是分配在公共池中(地址相同)，若采用<code>new</code>分配则分配在堆上</strong></p><h4 id="String常用的方法"><a href="#String常用的方法" class="headerlink" title="String常用的方法"></a>String常用的方法</h4></li></ol><ul><li><p><code>int length()</code> 获取字符串长度<br><strong>注意：对于字符串而言，获取长度是方法，而对于数组而言，获取长度是通过属性</strong></p></li><li><p><code>String concat(String str)</code> 连接两个字符串</p></li><li><code>char charAt(int index)</code> 返回指定索引处的字符</li><li><code>int compareTo(String str)</code> 按字典顺序比较两个字符串<ul><li>如果此字符串等于参数字符串，则返回值 0</li><li>如果此字符串小于字符串参数，则返回一个小于 0 的值</li><li>如果此字符串大于字符串参数，则返回一个大于 0 的值</li></ul></li><li><code>int indexOf(String str)</code> 返回指定子字符串在此字符串中第一次出现处的索引。</li><li><code>String replace(char oldChar, char newChar)</code> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</li><li><code>String replaceAll(String regex, String replacement)</code> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串</li><li><code>String[] split(String regex)</code> 根据给定正则表达式的匹配拆分此字符串。</li><li><code>char[] toCharArray()</code> 将此字符串转换为一个新的字符数组。</li><li><p><code>isEmpty()</code> 判断字符串是否为空。</p><h3 id="StringBuffer-类"><a href="#StringBuffer-类" class="headerlink" title="StringBuffer 类"></a>StringBuffer 类</h3><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer</p><h4 id="创建StringBuffer字符串与String大体相同"><a href="#创建StringBuffer字符串与String大体相同" class="headerlink" title="创建StringBuffer字符串与String大体相同"></a>创建StringBuffer字符串与String大体相同</h4><p>略</p><h4 id="StringBuffer方法"><a href="#StringBuffer方法" class="headerlink" title="StringBuffer方法"></a>StringBuffer方法</h4></li><li><code>StringBuffer append(String s)</code> 将指定的字符串追加到此字符序列</li><li><code>StringBuffer reverse()</code>  将此字符序列用其反转形式取代</li><li><code>delete(int start, int end)</code> 移除此序列的子字符串中的字符</li><li><code>insert(int offset, int i)</code> 将 int 参数的字符串表示形式插入此序列中的<code>i</code>位</li><li><code>replace(int start, int end, String str)</code> 使用给定 String 中的字符替换此序列的子字符串中的字符。</li><li><p>其余的方法与String相同</p><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，使用<code>getInstance</code>方法创建</p><h4 id="创建一个代表系统当前日期的Calendar对象"><a href="#创建一个代表系统当前日期的Calendar对象" class="headerlink" title="创建一个代表系统当前日期的Calendar对象"></a>创建一个代表系统当前日期的Calendar对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();<span class="comment">//默认是当前日期</span></span><br></pre></td></tr></table></figure><h4 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h4></li><li><p>Calendar.YEAR    年份</p></li><li><p>Calendar.MONTH    月份</p></li><li>Calendar.DATE    日期</li><li>Calendar.DAY_OF_MONTH    日期，和上面的字段意义完全相同</li><li>Calendar.HOUR    12小时制的小时</li><li>Calendar.HOUR_OF_DAY    24小时制的小时</li><li>Calendar.MINUTE    分钟</li><li>Calendar.SECOND    秒</li><li><p>Calendar.DAY_OF_WEEK    星期几</p><h4 id="Calendar类对象信息的获得"><a href="#Calendar类对象信息的获得" class="headerlink" title="Calendar类对象信息的获得"></a>Calendar类对象信息的获得</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);<span class="comment">// 获得年份</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">// 获得月份</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> date = c1.get(Calendar.DATE);<span class="comment">// 获得日期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hour = c1.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获得小时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minute = c1.get(Calendar.MINUTE);<span class="comment">// 获得分钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> second = c1.get(Calendar.SECOND);<span class="comment">// 获得秒</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4></li><li><p><code>add</code> 把cal对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算<br><code>c1.add(Calendar.DATE, 10);</code>‘</p></li><li><p>把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算<br><code>c1.add(Calendar.DATE, -10);</code></p></li></ul><hr><h2 id="Java图形界面"><a href="#Java图形界面" class="headerlink" title="Java图形界面"></a>Java图形界面</h2><h3 id="Java-GUI介绍"><a href="#Java-GUI介绍" class="headerlink" title="Java GUI介绍"></a>Java GUI介绍</h3><h4 id="AWT-Abstract-Window-Toolkit-："><a href="#AWT-Abstract-Window-Toolkit-：" class="headerlink" title="AWT(Abstract Window Toolkit)："></a>AWT(Abstract Window Toolkit)：</h4><p>  抽象窗口工具包，早期编写图形界面应用程序的包</p><h4 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h4><p>  Swing：为解决 AWT 存在的问题而新开发的图形界面包。Swing是对AWT的改良和扩展<br>  <strong>AWT和Swing都是java中的包，AWT包的名称是<code>java.awt</code>，Swing包的名称是<code>javax.swing</code></strong></p><h3 id="常用的组件-swing中"><a href="#常用的组件-swing中" class="headerlink" title="常用的组件(swing中)"></a>常用的组件(swing中)</h3><ul><li><strong><code>JLabel</code> 显示一行文字，可带图标</strong></li><li><strong><code>JTextFiel</code> 用户让用户输入一行文字的组件</strong></li><li><strong><code>JButton</code> 用于点击执行命令</strong></li><li><strong><code>JCheckBox</code> 复选框</strong></li><li><strong><code>JRadioButton</code>单选按钮</strong></li><li><strong><code>JComboBox</code>下拉列表框供选取</strong></li><li><strong><code>JList</code>一组列表项供选择</strong></li></ul><h3 id="顶层容器-——-JFrame"><a href="#顶层容器-——-JFrame" class="headerlink" title="顶层容器 —— JFrame"></a>顶层容器 —— JFrame</h3><ul><li>JFrame类是Window类的其中一个子类：通常用于定义一般意义的窗口</li><li>一个JFrame刚被创建后，其初始大小为height=width=0 ，而且是隐藏状态的，所以为了使Frame显示出来，必须在程序中显式地设置一下它的大小<br><strong>注意：<code>setVisible(true);</code>：数据模型已经构造好，允许JVM可以根据数据模型执行paint方法开始画图并显示到屏幕上</strong></li></ul><h3 id="Container类"><a href="#Container类" class="headerlink" title="Container类"></a>Container类</h3><p><code>Container</code>类是由<code>Component</code>类派生出来的一种特殊类，用来表示各种GUI组件的容器，其主要功能包括</p><ul><li>组件的管理：方法<code>add()</code>可以向其中添加一个组件，<code>remove()</code>删除其中的一个组件。</li><li>布局管理：每个Container类都和一个布局管理器相联，以确定其中组件的布局,通过<code>setLayout()</code>方法设置某种布局方式</li></ul><h3 id="中间容器-——-JPanel"><a href="#中间容器-——-JPanel" class="headerlink" title="中间容器 —— JPanel"></a>中间容器 —— JPanel</h3><p><code>JPanel（面板）</code>可以更方便地组织自己的组件，得到更合理的布局。但面板不能作为窗口独立支配系统资源，必须放在相关容器中才可见,因此，需要将<code>JPanel</code>添加到其他容器中得以运行</p><h3 id="组件的通用方法"><a href="#组件的通用方法" class="headerlink" title="组件的通用方法"></a>组件的通用方法</h3><ul><li><p><code>void setBackground(Color c)</code> : 设置组件的背景</p></li><li><p><code>Color getBackground()</code> :获取组件的背景色</p></li><li><code>void setForeground(Color c)</code> :设置组件的前景色</li><li><code>void setFont(Font f)</code> :设置组件的显示字体</li><li><code>Font getFont()</code> :获取组件的显示字体</li><li><code>void setEnabled(boolean b)</code> :是否让组件功能有效，在无效情况下组件变灰</li><li><code>void setVisible(boolean b)</code> :设置组件是否可见</li><li><code>void requestFocusInWindow()</code> : 让组件得到焦点</li><li><code>void add(PopupMenu popup)</code> ：给组件加入弹出菜单,但要和弹出菜单的show方法配合使用</li></ul><h3 id="常用组件及用法"><a href="#常用组件及用法" class="headerlink" title="常用组件及用法"></a>常用组件及用法</h3><h4 id="JLabel-标签组件"><a href="#JLabel-标签组件" class="headerlink" title="JLabel 标签组件"></a><code>JLabel</code> 标签组件</h4><ol><li><code>JLabel()</code> 创建空的标签</li><li><code>JLabel(String s)</code> 创建一个带初始字符串的标签</li><li><code>JLabel(String s，inti)</code> 创建一个带初始字符串及指定对齐方式的标签（i=0，2，4代表中左右）</li></ol><h4 id="JButton-按钮"><a href="#JButton-按钮" class="headerlink" title="JButton 按钮"></a><code>JButton</code> 按钮</h4><p>当组件被点击时，产生AcitonEvent事件</p><ol><li><code>JButton (String Label)</code> 建立一个标示字符串为Label的按钮类对象。</li><li><code>JButton(Icon icon)</code> 创建一个带图标的按钮。</li></ol><h4 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h4><h5 id="JTextField-单行文本框"><a href="#JTextField-单行文本框" class="headerlink" title="JTextField 单行文本框"></a><code>JTextField</code> 单行文本框</h5><p>单行文本框只能显示一行信息，会产生多种事件</p><ol><li><code>JTextField()</code> 创建空的单行文本框。</li><li><code>JTextField(int i)</code> 创建具有指定长度的文本框。</li><li><code>JTextField(String s)</code> 创建带有初始文本内容的文本框。</li><li><code>JTextField(String s,int i)</code> 创建带有初始文本内容并具有指定长度的文本框。</li></ol><h5 id="JTextArea-多行文本框"><a href="#JTextArea-多行文本框" class="headerlink" title="JTextArea 多行文本框"></a><code>JTextArea</code> 多行文本框</h5><ul><li>多行文本框可以显示多行信息，并且需要滚动条支持。按回车键后并不产生事件</li><li>文本域需用<code>setLineWrap(boolean wrap)</code>设置为<code>true</code>，否则可能在规定的宽度不换行。</li><li><code>TextArea</code>不支持直接滚动。要创建滚动边框，需要让<code>JTextArea</code>作为<code>JScrollPane</code>的视口视图</li></ul><h5 id="文本框的常用方法"><a href="#文本框的常用方法" class="headerlink" title="文本框的常用方法:"></a>文本框的常用方法:</h5><ul><li><code>getText()</code> 获取输入框中的数据</li><li><code>setText()</code> 往输入框写入数据</li><li><code>setEditable(boolean b)</code> 设置输入框是否可编辑。</li></ul><h4 id="JCheckBox-复选框"><a href="#JCheckBox-复选框" class="headerlink" title="JCheckBox 复选框"></a><code>JCheckBox</code> 复选框</h4><p>提供简单的选择框，同时旁边还可以显示说明信息。当复选框状态发生变化时，会产生<code>ItemEvent</code>事件  </p><h5 id="常用构造方法："><a href="#常用构造方法：" class="headerlink" title="常用构造方法："></a>常用构造方法：</h5><p><code>JCheckBox(String,boolean)</code> 创建一个指定显示标签和初始状态的复选框</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>boolean isSelected()</code> 获取复选按钮的选中状态，返回<code>true</code>代表按钮被选中</li><li><code>void setSelected(boolean value)</code> 设置复选按钮的状态，<code>value</code>为<code>true</code>表示选中。</li></ul><h4 id="选框组-ButtonGroup-——单选框"><a href="#选框组-ButtonGroup-——单选框" class="headerlink" title="选框组(ButtonGroup)——单选框"></a>选框组(ButtonGroup)——单选框</h4><p>当<code>JRadioButton</code>组件单独使用时，与复选框相同；如果利用<code>ButtonGroup</code>类分组，同一组的<code>JRadioButton</code>就构成单选框。选框组中的单选框之间是相互关联的，每次有且只有一个处于选中状态。</p><h4 id="JComboBox-下拉列表"><a href="#JComboBox-下拉列表" class="headerlink" title="JComboBox 下拉列表"></a><code>JComboBox</code> 下拉列表</h4><p>下拉列表也称作组合框。它也可以通过<code>addItem (Object s)</code>方法增加选项，但每次只能选择一项。当选择发生时，会产生<code>ItemEvent</code>事件</p><h5 id="下拉列表常用方法"><a href="#下拉列表常用方法" class="headerlink" title="下拉列表常用方法"></a>下拉列表常用方法</h5><ul><li><code>int getSelectedIndex()</code> 获取所选列表项对应的编号；</li><li><code>Object getSelectedItem()</code> 获取所选列表项对应的文字信息；</li><li><code>void addItem (Object s)</code> 添加新列表项元素到列表中;</li><li><code>void removeItemAt (int Index)</code> 删除某个列表项元素;</li><li><code>void removeAllItems()</code> 删除所有列表项元素。</li></ul><h3 id="外观布局"><a href="#外观布局" class="headerlink" title="外观布局"></a>外观布局</h3><ul><li>在容器（JFrame和JPanel）中所有组件的布局都由布局管理器来控制，他们都有各自默认的布局管理器，也可以依据自身要求指定一个新的布局管理器</li><li>容器中布局管理器会自动设置各组件的大小和位置，用户无法手动改变这些属性，<code>即setLocation()</code> , <code>setSize()</code> , <code>setBounds()</code>等方法无效<h4 id="流式布局-FlowLayout"><a href="#流式布局-FlowLayout" class="headerlink" title="流式布局(FlowLayout)"></a>流式布局(FlowLayout)</h4>FlowLayout以流式的方式，自左向右，自上而下的依次放置容器中的组件，一行放不下时再换行，使用组件的最佳尺寸来显示组件。  </li></ul><p>当容器被重新设置大小后，则布局也会随之发生改变：各组件的大小不变，但相对位置会改变。<br><strong>FlowLayout类有三种构造方法：</strong></p><ul><li><p><code>public FlowLayout()</code><br>组件采用居中对齐方式，组件间的水平和竖直间距为默认值5个像素。</p></li><li><p><code>public FlowLayout(int align)</code><br>使用指定的对齐方式（值=0,1,2，代表左中右)，水平和竖直间距为缺省值5像素。</p></li><li><code>public FlowLayout(int align, int hGap, int vGap)</code><br>使用指定的对齐方式、水平间距、竖直间距。</li></ul><h4 id="网格布局-GridLayout"><a href="#网格布局-GridLayout" class="headerlink" title="网格布局(GridLayout)"></a>网格布局(GridLayout)</h4><p>GridLayout布局方式可以使容器中的各组件呈网格状分布。各组件的排列方式仍为从上到下，从左到右。  </p><p>容器中各组件的高度和宽度相同，当容器的尺寸发生变化时，各组件的相对位置不变，但各自的尺寸会改变。<br><strong>GridLayout类有三种构造方法：</strong></p><ul><li><p><code>public GridLayout()</code><br>在一行中放置所有的组件，各组件间的<strong>水平间距为0像素</strong></p></li><li><p><code>public GridLayout(int rows, int cols)</code><br>生成一个rows行，cols列的管理器，最多能放置rows*cols个组件。</p></li><li><code>public GridLayout(int rows, int cols, int hGap, int vGap )</code><br>各组件间的水平和竖直间距为指定值<h4 id="边框布局-BorderLayout"><a href="#边框布局-BorderLayout" class="headerlink" title="边框布局(BorderLayout)"></a>边框布局(BorderLayout)</h4>BorderLayout布局将整个容器的区域分为<code>East</code>, <code>South</code>, <code>West</code>, <code>North</code>和<code>Center</code>五个部分，加入组件时需指明放置的位置，如果未指定位置，则位置是<code>Center</code>。  </li></ul><p>当容器的尺寸发生变化时，各组件的相对位置不变，四周组件的厚度不会被改变，中间组件的大小需要改变<br><strong>BorderLayout类有二种构造方法：</strong></p><ul><li><p><code>public BorderLayout()</code><br>各组件间的水平和竖直间距为缺省值0个像素。</p></li><li><p><code>public BorderLayout(int hGap, int vGap)</code><br>各组件间的水平和竖直间距为指定值。  </p></li></ul><p>若容器使用了BorderLayout布局，用add()方法往容器中添加组件时必须指明添加的位置，若没有指明放置位置，则添加在默认的“Center”方位。</p><hr><h2 id="Java事件处理-窗口"><a href="#Java事件处理-窗口" class="headerlink" title="Java事件处理(窗口)"></a>Java事件处理(窗口)</h2><h3 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h3><ol><li><strong>对于某种类型的<code>xxxEvent</code>，要接受并处理该类时间，必须先定义对应的事件监听器类，该类需要实现针对该类事件的特定接口<code>xxx Listener</code></strong></li><li><strong>实现该类中事件处理的所有方法</strong></li><li><strong>对于事件源，使用<code>add xxxListener</code>注册该类事件的监听器</strong></li></ol><h3 id="事件适配器类xxxAdapter"><a href="#事件适配器类xxxAdapter" class="headerlink" title="事件适配器类xxxAdapter"></a>事件适配器类xxxAdapter</h3><p>通过实现接口<code>xxxListener</code>对事件进行处理时，需要实现该接口中的所有方法，但通常只需要对其中的某些方法进行处理，因此JDK为某些监听器接口提供了适配器类  </p><p>当需要对某种事件进行处理时，只需要让<strong>事件处理类</strong>继承事件所对应的适配器类，只重写需要关注的方法而不用处理其他</p><h3 id="监听器、对应适配器"><a href="#监听器、对应适配器" class="headerlink" title="监听器、对应适配器"></a>监听器、对应适配器</h3><div align=center><img src="https://s3.ax1x.com/2020/12/19/rNQGJP.png" width="80%" height="80%"></div><hr><h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p>异常是一个对象,它继承自<code>Throwable</code>类，该类在<code>java.lang</code>包中,所有的<code>Throwable</code>类的子类所产生的对象都是异常.  </p><ul><li><p><code>Error</code>:<br>内部错误，由Java虚拟机生成并抛出,Java程序不做处理.</p></li><li><p><code>Runtime Exception</code>(运行时异常：被0除、数组下标超范围等):<br>由系统运行时检测, 用户的Java 程序可不做处理,系统将它们交给缺省的异常处理程序.</p></li><li><code>Checked Exception</code>(程序中可预知的问题：IO异常):<br>Java编译器要求Java程序必须捕获或声明所有的非运行时异常</li><li><code>throw</code>:<br>强行抛出用户自己产生异常</li></ul><h3 id="常见的异常处理"><a href="#常见的异常处理" class="headerlink" title="常见的异常处理"></a>常见的异常处理</h3><ul><li><code>ClassNotFoundException</code> 指定的类不存在</li><li><code>IllegalArgumentException</code> 方法的参数错误</li><li><code>NoSuchMethodException</code> 方法不存在异常</li><li><code>ArithmeticException</code> 数学运算异常</li><li><code>ArrayIndexOutOfBandsException</code> 数组下标超出范围</li><li><code>ArrayStoreException</code> 数组存储异常</li><li><code>IOException</code> 不能操作I/O</li><li><code>FileNotFoundException</code> 文件未找到异常</li><li><code>NullPointerException</code> 对象参考值为Null</li><li><code>NumberFormatException</code> 字符串转换数值</li></ul><h3 id="捕获异常并处理"><a href="#捕获异常并处理" class="headerlink" title="捕获异常并处理"></a>捕获异常并处理</h3><p>示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//接受监视的程序块,在此区域内发生</span></span><br><span class="line">  <span class="comment">//的异常,由catch中指定的程序处理;</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(要处理的异常种类对象e1) &#123;</span><br><span class="line">  <span class="comment">//处理异常;</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(要处理的异常种类对象e2) &#123;</span><br><span class="line">  <span class="comment">//处理异常;</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception n) &#123;</span><br><span class="line">  <span class="comment">//处理其他的异常;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一定会执行的程序块-——-finally"><a href="#一定会执行的程序块-——-finally" class="headerlink" title="一定会执行的程序块 —— finally"></a>一定会执行的程序块 —— <code>finally</code></h3><p>不论发生什么异常(或者不发生任何异常),都要执行的部分，在文件处理时非常有用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//对文件进行处理的程序;</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">  <span class="comment">//对文件异常进行处理;</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  不论是否发生异常,都关闭文件;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="异常的声明"><a href="#异常的声明" class="headerlink" title="异常的声明"></a>异常的声明</h3><p><strong><code>throws</code>和<code>throw</code></strong>：  </p><ul><li><code>throws</code> 用来声明一个方法可能产生的<strong>所有异常</strong>，不做任何处理而是将异常往上传，<strong>谁调用我我就抛给谁</strong></li><li><code>throw</code> 则是用来抛出一个具体的异常类型</li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>在方法后边声明异常，其实就是自己不想对异常做出任何的处理，告诉别人自己可能出现的异常，交给别人(谁调用的)处理，然后交给他处理<br>比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">//丢给上一层</span></span><br><span class="line">    <span class="keyword">int</span> t=i/j;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//丢给JVM</span></span><br><span class="line">    Math m=<span class="keyword">new</span> Math();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>自己处理一个异常，有两种方式要么是自己捕获异常<code>try...catch</code>代码块，要么是抛出一个异常（<code>throws</code> 异常）<br>用来明确地抛出一个异常，在判断成立时：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常；</span><br><span class="line"><span class="comment">//example:</span></span><br><span class="line">&lt;方法名&gt; (&lt;参数行&gt;) [<span class="keyword">throws</span>&lt;异常类<span class="number">1</span>&gt;，&lt;异常类<span class="number">2</span>&gt;…]&#123;</span><br><span class="line">  <span class="keyword">if</span> (异常条件<span class="number">1</span>成立)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> 异常<span class="number">1</span>（）;</span><br><span class="line">  <span class="keyword">if</span> (异常条件<span class="number">2</span>成立)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> 异常<span class="number">2</span>（）;</span><br><span class="line">…</span><br><span class="line">&#125; <span class="comment">//含有throw 抛出异常的方法，方法头要加上throws 异常列表</span></span><br></pre></td></tr></table></figure></p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>注意：  </p><ul><li><p>自定义异常不是由Java系统监测到的异常,而只能由用户自己定义的异常</p></li><li><p>异常是一个类,用户定义的异常必须继承自<code>Throwabl</code>e或<code>Exception</code>类,建议用<code>Exception</code>类，便于由<code>Exception</code>类统一处理</p></li><li>用户定义的异常必须由用户自己抛出，<code>throw new MyException()</code>，同样要用<code>try--catch</code>捕获。</li></ul><p>比如：  </p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">  AgeException()&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">&quot;年龄不正常&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">  MyException2(String str)&#123;</span><br><span class="line">    <span class="keyword">super</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="Java-Stream-File"><a href="#Java-Stream-File" class="headerlink" title="Java Stream/File"></a>Java Stream/File</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Java IO读写文件的IO流分为两大类，字节流和字符流</p><ul><li><strong>基于字节流的读写基类: <code>InputStream</code> 和 <code>OutputStream</code></strong>  </li></ul><p>其中比较重要的有<code>BufferedInputStream</code> , <code>FileInputStream</code> 和 <code>BufferedOutputStream</code> ， <code>FileOutputStream</code></p><ul><li><strong>基于字符流的读写基类: <code>Reader</code> 和 <code>Writer</code></strong>  </li></ul><p>其中比较重要的有<code>BufferedReader</code> , <code>FileReader</code> , <code>InputStreamReader</code> 和 <code>BufferedWriter</code> , <code>FileWriter</code> , <code>InputStreamWriter</code></p><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><code>InputStreamReader</code></h4><p><code>InputStreamReader</code> 将<strong>字节流</strong>转换为<strong>字符流</strong>。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码，如：GBK</p><h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a><code>OutputStreamWriter</code></h4><p><code>OutputStreamWriter</code> 将<strong>字符流</strong>转换为<strong>字节流</strong>。是字符流通向字节流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码，如：GBK</p><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File(String filePath);<span class="comment">//filePath:文件路径</span></span><br></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li><p><strong><code>public boolean exists()</code> 测试此抽象路径名表示的文件或目录是否存在</strong></p></li><li><p><strong><code>public boolean isDirectory()</code> 测试此抽象路径名表示的文件是否是一个目录</strong></p></li><li><strong><code>public boolean isFile()</code> 测试此抽象路径名表示的文件是否是一个标准文件</strong></li><li><strong><code>public long lastModified()</code> 返回此抽象路径名表示的文件最后一次被修改的时间</strong></li><li><strong><code>public long length()</code> 返回由此抽象路径名表示的文件的长度</strong></li><li><strong><code>public boolean delete()</code> 删除此抽象路径名表示的文件或目录</strong></li><li><strong><code>public boolean createNewFile() throws IOException</code>当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件</strong></li><li><strong><code>public boolean mkdir()</code> 创建此抽象路径名指定的目录</strong></li><li><strong><code>public boolean delete()</code> 删除此抽象路径名表示的文件或目录</strong></li></ul><hr><h2 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h2><ul><li><p><strong>java中没有按位左移运算符<code>&lt;&lt;&lt;</code></strong></p></li><li><p><strong>创建对象时,数据分配在堆空间,因为堆空间采用链式存储结构,所以能存大量的数据</strong></p></li><li><strong>抽象方法是没有方法体的方法</strong></li><li><strong>Java API文档不包括: 父类方法的列表</strong></li><li><strong>JDK中并没有为所有的监听器接口都提供相应的适配器类</strong></li><li><p><strong>java变量是否需要初始化</strong><br>1、<strong>成员变量：</strong> 无需初始化<br>  成员变量无需初始化，系统在创建实例的过程中默认初始化。<br>  补充：以<code>final</code>修饰的成员变量。必须显性的初始化赋值。</p><p>2、 <strong>方法里面的形参变量：</strong> 无需初始化<br>  Java类方法，属于按值传递机制，调用方法的时候，完成参数的传递，相当形参被初始化。</p><p>3、<strong>局部变量：</strong> 必须初始化</p></li><li><p><strong>JTabbedPane: 选项卡面板</strong></p></li><li><p><strong>各种进制表示</strong></p><ul><li>二进制： 以 <code>0b</code> 或者 <code>0B</code> 开头</li><li>八进制： 以 <code>0</code> 开头</li><li>十六进制： 以 <code>0x</code> 或者 <code>0X</code> 开头</li></ul></li><li><p><strong><code>StringBuffer</code> 的初始容量为16</strong></p></li><li><strong>Java文档注释：  /** balabala */</strong></li><li><strong>Java的字符类型采用的是Unicode编码方案，每个Unicode码占<code>16</code>个比特位</strong></li><li><strong>“一次编译、到处运行” 说的是Java语言跨平台的特性</strong></li><li><strong>Java是通过多线程来实现并发机制的</strong></li><li><strong>在 java 源文件中 <code>import</code> 语句应位于 <code>package</code> 语句之后，所有类的定义之前，即先创建当前包，再引用其他包</strong></li></ul><hr><h2 id="最后想说的"><a href="#最后想说的" class="headerlink" title="最后想说的"></a>最后想说的</h2><p>本篇博客完全是根据自己的掌握情况写的，由于要应付考试，所以其中的重点可能拿捏得不符合一些人的口味，请见谅。后面还会出更多更深入的文章记录Java的学习过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机是如何一步步控制你的</title>
      <link href="article/addiction/"/>
      <url>article/addiction/</url>
      
        <content type="html"><![CDATA[<p>资本主义精心设计的成瘾模型，接很久以前的一篇<a href="https://codgi.xin/article/games/">文章</a>，对以前写的内容的追加思考</p><a id="more"></a><h2 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h2><p>你是这样的人吗，每次上网搜索东西时，总被其他热点标题吸引，转而忘了正事，走在路上时，总是不自觉拿起手机刷来刷去，但到底为什么要拿出手机，又在刷什么，你自己也不清楚。老早地躺进被窝，把熟悉的应用、热点新闻、朋友圈全都刷了个遍，还是没睡着，最后打开了网易云  </p><h2 id="初步原因"><a href="#初步原因" class="headerlink" title="初步原因"></a>初步原因</h2><p>不止是你一个人拥有这样的困扰，在今天，拥有电子设备的现代人几乎都有这样的困扰，是我们网络成瘾了吗？是我们自制力不够吗？问题不一定出在你身上，有可能在你每天都在用的设备和程序上</p><h2 id="下拉刷新，上划永无止境"><a href="#下拉刷新，上划永无止境" class="headerlink" title="下拉刷新，上划永无止境"></a>下拉刷新，上划永无止境</h2><p>为什么你手机里常用的很多APP，无一不采用类似的设计，为什么好像所有APP都想给你推送信息，获取你的隐私信息；为什么<code>点赞</code> <code>收藏</code> <code>分享</code> <code>转发</code>，会成为这些APP内最常见的按钮，为什么越来越多的视频平台总是自动播放下一支视频或者循环播放，并且你不按停止，他能一直这样</p><h2 id="引入参考书籍《上瘾》"><a href="#引入参考书籍《上瘾》" class="headerlink" title="引入参考书籍《上瘾》"></a>引入参考书籍《上瘾》</h2><p>早在2017年电子设备增长浪潮时，当人们还在热议如何戒掉手机瘾时，一本畅销书正在创业者、产品、和广告人中间风靡，书中用一个简化的模型指导你如何打造一款让人欲罢不能的爆款上瘾产品。<br>这本书在某些行业甚至被奉为“圣经”，名字就叫做《上瘾》</p><blockquote><p>《上瘾》：让用户养成使用习惯的四大产品<br>【美】尼尔·埃亚尔、【美】瑞安·胡佛  </p></blockquote><h2 id="上瘾模型"><a href="#上瘾模型" class="headerlink" title="上瘾模型"></a>上瘾模型</h2><p>书中这个简化的模型被称为上瘾模型，通过<code>触发-&gt;行动-&gt;酬赏(多变)-&gt;投入</code>，简简单单四个步骤，就能让用户在不知不觉中，养成使用习惯，甚至上瘾。<br>据统计，人类几乎一半的日常活动都受制于习惯。 </p><p><strong>论文引入:</strong><br>根据一篇名为《基底神经节在习惯形成中的作用》的论文，神经系统学家认为，人脑中存在一种负责无意识行为的基底神经节，很多无意识产生的条件反射都会被存储下来，这样，我们的大脑就能腾出更多精力关注其他的事情。而所谓习惯，就是大脑遇到类似环境时，所产生的无意识行为：  </p><ol><li>不自觉的口头禅</li><li>脱口而出的脏话</li><li>紧张时的挠头  </li><li>有推送就想看看</li><li>走路或者乘车时拿起手机</li></ol><hr><h3 id="第一阶段——触发"><a href="#第一阶段——触发" class="headerlink" title="第一阶段——触发"></a>第一阶段——触发</h3><p><strong>所有包括但不限于上述提及的习惯，都是由某个触发开始</strong><br>生活中的日常触发大多都是随机性的，而产品的触发却都潜藏在信息中，暗示着用户：你接下来要做什么<br>你想打开这个应用，因为APP上的小红点触发了你的强迫症；你想打开朋友圈或者空间，因为你又能看到新的动态了；你想下拉刷新一下信息流，因为下次刷新总能刷到自己喜欢的内容。<br>触发的形式繁多，早期的滴滴打车和拼多多的补贴还有花呗返现免单就是<code>付费型触发</code>。你在社交网络上收到的关注、点赞、收藏，甚至拼多多的拼单就是<code>人际型触发</code>。信息推送也算是一种触发，不过，这些都来自外部，而和情绪相关的内部触发更为有效。而且负面情绪的触发更为强大，他们一旦产生，你们就不自觉想要打压。<br>无聊时你想看看新闻热榜，孤独时你想刷刷朋友圈，压力大时你想刷抖音。这种头疼医头，脚疼医脚的方式，虽然不能在根本上解决问题，但总能以最快的速度和最低的成本让你解决当下的负面感受，久而久之就变成一种可以存储在基底神经节中的<strong>习惯</strong></p><hr><h3 id="第二阶段——行动"><a href="#第二阶段——行动" class="headerlink" title="第二阶段——行动"></a>第二阶段——行动</h3><p>但要你正在行动起来，成为他们的用户，乃至长期用户，甚至付费用户，光有这简简单单的触发还远远不够  </p><blockquote><p>斯坦福大学说服技术研究实验室主任Dr. BJ Fogg建立了一个行为模型——Fogg Behavior Model，用 <code>B=MAP</code>表示</p></blockquote><p>即<code>行为=动机(M)*能力(A)*触发器(P)</code>，也就是说要一个人完成特定的行为，除了需要触发器以外，还需要他有这个动机以及能力。<br>驱使人们采取行动的核心动机就三种：感觉、预期和归属感。每一种都包含两个方面：</p><ol><li>感觉：追求快乐、逃避痛苦</li><li>预期：追求希望、逃避恐惧</li><li>归属：追求认同、逃避排斥</li></ol><p>但有触发，有动机也不见得能激发人们行动，因为能力也至关重要，如果一个人没有能力做到某件事，按照Fogg的行为模型，你只有两种办法：</p><ol><li>给他这项能力，比如培训或者工具</li><li>简化目标、降低预期<h4 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h4>博客兴起的时代，不是每个人都能动辄千八百字，为了能让更多地人都能加入写博客，我们限定每次最多只能写140个字符，于是Twitter起来了，微博诞生了。<br>评论虽然很有意思，但是写字很麻烦，没事，只要你觉得好，轻轻一点给个赞；收藏也简化，轻轻一点加入收藏夹；转发也简化，轻轻一点多种渠道都能转发。<br>以至现在的App哪个不加这啊是哪个基础功能就等于站在了用户的对立面。<br>到后来翻页也成为了一种阻碍，因为你已经没有耐心等待加载，没关系，现在我们有瀑布流，只需要轻轻滑，翻到底后会自动加载更多；搜索框不知道搜索什么，没关系，我帮你推荐点热搜，都是你最感兴趣的。<br>总结一下，通过这个模型，如果你没有时间，一切都将为你变得更简单、更快、更方便；如果你没有钱，我们可以免费；就算你没有脑力和体力，这一切我们也帮你简化了。<br>还有一部分来自人脑自身的机制或者缺陷，比如人脑一次性只能处理很少的信息，所以我们这几年看到的UI或者其他设计都在逐渐简化，简化到即使没有文字描述，光是看见这个图标就能知道它大概的作用，这种做法在其中潜藏精准而明确的指示，只为触发你的某一个行动。还有研究表明，人眼比较容易被深色、暖色吸引，所以很多App的迭代更新，在自身图标上做得也越来越契合这个方面。</li></ol><hr><h3 id="第三阶段——酬赏"><a href="#第三阶段——酬赏" class="headerlink" title="第三阶段——酬赏"></a>第三阶段——酬赏</h3><p><strong>当你行动起来，你就能获得来自产品的酬赏，并且是多变的酬赏</strong><br>在上瘾模型中，这些酬赏被分为三种：<code>社交酬赏</code>、<code>猎物酬赏</code>、<code>自我酬赏</code>。  </p><h4 id="猎物酬赏"><a href="#猎物酬赏" class="headerlink" title="猎物酬赏"></a>猎物酬赏</h4><p>猎物酬赏是人们最容易意识到的部分：金钱奖励、资源回馈、以及获得更多信息。<br>当你阅读自己感兴趣的新闻时，再刷一下，总有一条让你更感兴趣的；为了搜索一张图片，你能看到无数类似或者让人更舒爽的图片；看完一个视频，下面还有更有意思的，而社交酬赏实际上在互联网世界中更有分量，在他人的点赞和评论中，你能获得足够多的肯定，激发你得创作、分享、参与的欲望，如果你在应用中获得某种成就感或者掌控感，那将是一种自我酬赏。  </p><blockquote><p>心理学家Skinner在上世纪五十年代开展了这样一项研究：<br>把鸽子放进笼子里，鸽子慢慢发现：啄一下按钮就能获得食物。然后做一点小小的改动：鸽子啄一下按钮只能间歇地获得食物，这时候鸽子啄按钮地频率会加快<br>早年与这个实验最接近的应该是赌博中的老虎机</p></blockquote><p>而现在，像不像打开软件或者刷新信息列表，却不知道在看什么的我们</p><hr><h3 id="第四阶段——投入"><a href="#第四阶段——投入" class="headerlink" title="第四阶段——投入"></a>第四阶段——投入</h3><p><strong>触发、行动、酬赏之后，还需要让人们投入到产品中，才算是完成了整个上瘾模型的回路</strong><br>你在该产品上积累的各种价值、发布的照片或视频、积累的关注或点赞以及知名度、基于产品所学会的知识技能等，都将是你无法离开的原因。然后，下一个触发，还在继续。<br>在整本书中，只有不到10页聊到了道德操控，他提出了一个直接的问题：上瘾模型算不算精神控制？<br>现在：经过这么久的讲解，你说呢？</p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>让我们回到B=MAP,这个重要的模型公式，首先：<br>触发是不可改变的，无数的触发器已经安装或者正在被安装进你的生活，其次在很多产品中，他们往往把能力的权重放在动机之前，所以如果你有一点点意识到：某些行为对你来讲是负面的，你可以想办法降低能力值掌控提高能力的值，来减少行动的可能性。  </li></ol><ul><li>比如，手机打开锁屏后，第一屏根本没有那些应用</li><li>关掉没有必要的消息推送</li></ul><p>但是这些措施仍然是头疼医头，脚疼医脚，不能完全解决问题，基本持续最多一周后就会恢复原样，这也是著名的<code>王境泽定律</code>。  </p><p>人的所有行动都有他的目的，如果这个目的不属于你，那就属于你的DNA，你的动物脑，DNA需要生存、延续，所以我们的动物脑有好的一面，也会有他懒惰、贪婪的一面  </p><p><strong>但最根本的问题是，你，我是说：你打算把你的时间和注意力，花在哪里</strong></p><blockquote><p>我们生活在物的时代，我们根据他们的节奏和不断替代的现实而生活着 —— 让·鲍德里亚《消费社会》</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>已购赛博朋克2077</title>
      <link href="article/newgame/"/>
      <url>article/newgame/</url>
      
        <content type="html"><![CDATA[<p>对不起没忍住，入手价格149r，给🐻冲！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高数考试范围</title>
      <link href="article/math/"/>
      <url>article/math/</url>
      
        <content type="html"><![CDATA[<p>我们高数老师专门为我们开了一节课来讲期末考试的高数考试范围<br>wdm 我又可以了，记录一下，冲冲冲<br><a id="more"></a></p><h1 id="考试大纲"><a href="#考试大纲" class="headerlink" title="考试大纲"></a>考试大纲</h1><p>我们学校的考试卷子只有 选择、填空、解答题 三种题型，其中  </p><ol><li>选择题 每题4分、共5道、记20分</li><li>填空题 每题4分、共6道、记24分‘</li><li>解答题 每题8/10分、共7道，记56分<br>这次的复习课直接明确给出了选择题必考的三种题型、填空题必考的三种题型以及所有解答题的题型(总共92分XD)</li></ol><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p><strong>1. 求多元函数的定义域</strong><br>    &#160;非常简单，有手就行</p><p><strong>2. 判断直线与平面的位置关系</strong><br>    &#160;直接找方向向量和法向量的关系然后判断<br>    &#160;如果方向向量和法线垂直，特别注意直线和平面的<strong>重合情况</strong></p><p><strong>3. 求待定系数</strong><br>    &#160;其实就是 <strong>已知全微分，求未知数</strong>  </p><ul><li>解题方法：找出已知全微分中的P、Q，令$\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial x}$ 即可，解出其中的未知数</li></ul><p><strong>4. 交换二重积分次序</strong><br>    &#160;注意积分上下限的变化以及交换后式子的正负号</p><p><strong>5. 待定单选</strong>  </p><ul><li>下列说法正确的是(连续、可导、可微的关系)</li><li>级数在某个范围的收敛域<br><strong>个人觉得大概率是级数的题</strong></li></ul><hr><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><p><strong>1. 求二元函数(在某点的)全微分</strong>  </p><ul><li><p>求全微分：<br>${\mathrm{d}z}=\frac{\partial z}{\partial x}\mathrm{d}x+\frac{\partial z}{\partial y}\mathrm{d}y$</p></li><li><p>在某点的全微分：  </p><script type="math/tex; mode=display">{\mathrm{d}z(x_0,y_0)}=\frac{\partial z}{\partial x}|_{(x_0,y_0)}\mathrm{d}x + \frac{\partial z}{\partial y}|_{(x_0,y_0)}\mathrm{d}y</script><p><strong>即求出全微分后带入点</strong></p></li></ul><p><strong>2. 二元函数的极限</strong><br>&#160;即计算重极限，三种解题情况：  </p><ol><li>设 $xy=r$ (多项式均为 $x·y$ 情况时)</li><li>将式子拆分为 C·0 型(多用在式子中包含$\frac{C_1·(x^2)^a+C_2·(y^2)^b}{(x^2+y^2)^a}$ 时)</li><li>设$<br>\begin{cases}<br>x = x_0+r·\cos\theta \<br>y = y_0+r·\sin\theta<br>\end{cases}<br>$ （式子中x、y均为$x^2、y^2$时）</li></ol><p><strong>3. 第二类曲面积分</strong><br>&#160;重点考高斯公式(看内外侧，注意正负)，其余的看自己笔记本(XD太多了懒得写)</p><p><strong>4. 第一类曲线积分</strong><br>可以换成直线方程、参数方程，但也别忘了可以直接代入<br>注意按性质计算的情况：  </p><ol><li>$\int_{L} 1\, ds = L$ 的长度</li><li>关于$x=0、y=0$对称时的情况</li></ol><p><strong>5. 物理应用</strong><br><strong>明确指出：平面薄片的质量</strong></p><p><strong>6. 待定填空题</strong>  </p><ul><li>旋转后方程</li><li>幂级数展开</li><li>梯度</li></ul><hr><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><p><strong>1. 曲面在某点处的切平面、法线方程</strong><br>求出曲面在该点的切平面的法向量(该点处曲面的法向量)，然后用平面的点法式方程和直线的对称式方程分别表示出切平面方程和法线方程</p><p><strong>2. 抽象函数的一阶偏导</strong><br>&#160;主要是考察链式法则和用 $f’$ 表示偏导数</p><p><strong>3. 二重积分</strong><br>这个是真烦<br>简单的题直接土方法干，麻烦一点的涉及到:  </p><ul><li><strong>通过交换积分次序计算积分</strong><br>&#160;适用交换后计算更方便的情况</li><li><strong>通过极坐标变换计算积分</strong><br>&#160;积分区域被两条从原点发出的射线切割且圆润</li><li><strong>通过直线角坐标变换计算积分</strong><br>&#160;与通过极坐标变换计算积分的方法相反</li><li><strong>通过对称性计算积分</strong><br>&#160;关于$x、y、z$对称的三种情况</li><li><strong>通过轮换对称性计算积分</strong><br>&#160;积分区域关于直线$y=x$对称，且$f(x,y)+f(y,x)$的积分更好求</li><li><strong>通过积分区域形心计算积分</strong><br>&#160;被积函数=$?y+?x$，且形心好找或者关于$y=?$或$x=?$对称<br>计算方法：$\iint_{D} (ax+by)\, dx\,dy=(a\overline{x}+b\overline{y})·D的面积 ,(\overline{x},\overline{y})为D的形心坐标$</li></ul><p><strong>4. 三重积分</strong><br>&#160;<strong>局限在柱面坐标</strong><br>&#160;不好意思，这个我复习漏了呜呜呜呜呜呜呜，马上写完就去看</p><p><strong>5. 第二类曲线积分</strong><br>&#160;考察格林公式</p><p><strong>6. 全微分求原函数</strong><br>？我怎么没遇见过这种的  </p><ul><li><p>做题方法：<br>题目里面会给出$\frac{\partial u}{\partial x} 和 \frac{\partial u}{\partial y}$</p><p>$u=\int<em>{x_0}^{x}·(y 变成y_0后的 \frac{\partial u}{\partial x})dx + \int</em>{y_0}^{y} · \frac{\partial u}{\partial y}dy+C$</p><p>$x_0,y_0随便找，只要带入 \frac{\partial u}   {\partial x} 和 \frac{\partial u}{\partial y}$<br>中有意义即可(就是只要分母不为0)</p></li></ul><p><strong>7. 证明绝对收敛</strong><br>这个我智商不够，考试的时候随缘做吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>别搁这儿总结了，赶快去看吧，我还有好多没看完</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记本屏幕亮度问题</title>
      <link href="article/lights/"/>
      <url>article/lights/</url>
      
        <content type="html"><![CDATA[<p>亮度无法调节问题是出在这台笔记本电脑上的，以前都是重新装个驱动就好了，以为这次是中邪了，结果意外刷到了一篇文章，刚好解决了这个问题<br>wdnmd我的眼睛有救了<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我拿到这台电脑使用了很长一段时间都是没有问题的，晚上打游戏都是降低了亮度玩，结果有一次晚上发现无法调节亮度，去找了很多方法都没有成功，导致我的笔记本屏幕满亮度使用了起码有半年多的时间(我的眼睛呜呜呜)</p><h2 id="尝试过的解决办法"><a href="#尝试过的解决办法" class="headerlink" title="尝试过的解决办法"></a>尝试过的解决办法</h2><ul><li>重装系统  (注：后面又用不能调节了)</li><li>卸载显卡驱动程序并重装</li><li>更新驱动程序</li></ul><p><strong>除了重装系统后一段时间内能正常调节，其他方法均无效</strong></p><h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h2><p><strong>远程连接软件<a href="https://www.teamviewer.com/">TeamViewer</a></strong>  </p><p>无意间刷CSDN刷到的一篇<a href="https://blog.csdn.net/weixin_40930415/article/details/104403071">博文</a>发现的  </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>那篇博文里面提到了TeamViewer可能会导致亮度调节失效，于是我尝试了去设备管理器里将<code>监视器</code>下的<code>Generic Monitor (OrayDPMS)</code>卸载，然后检测硬件改动后他又回来了……<br>又查看了几个方法，去TeamViewer内将驱动卸载，结果提示我没有安装(exm?) 那对不住了，找到元凶了还不能让我干掉你，那我就把你卸了(/滑稽)  </p><p>然后尝试<code>Fn+F11/F12</code>  </p><p><strong>完美解决问题 Nice！ 我的眼睛有救了</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可能你会问我是怎么在晚上顶着高亮度坚持下来的<br>实在没办法我找到了一个软件：<a href="https://justgetflux.com/">f.lux</a><br>他能设置一天内你屏幕的色温，我把晚上的色温调得很暖，减少了眼睛了压力(没有直接降低亮度来的爽，现在两个结合起来更舒服了)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入手一台Raspberry Pi 4B</title>
      <link href="article/RaspberryPi/"/>
      <url>article/RaspberryPi/</url>
      
        <content type="html"><![CDATA[<p>近段时间想学学Linux方面的东西，但是Windows上的WSL我觉得虽然方便，但是用着没有单独Linux<br>那么畅快，所以入手Raspberry Pi来拿玩，但愿不要太快就吃灰了。  </p><p>这篇记录下Raspberry Pi的踩坑记录（md）<br><a id="more"></a></p><h1 id="Raspberry-Pi"><a href="#Raspberry-Pi" class="headerlink" title="Raspberry Pi"></a>Raspberry Pi</h1><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="1-HDMI无信号"><a href="#1-HDMI无信号" class="headerlink" title="1. HDMI无信号"></a><strong>1. HDMI无信号</strong></h3><p>这个是个神奇的问题，我在把镜像文件（Ubuntu 18）烧录至SD卡后，插入Raspberry Pi后，连接上键盘和HDMI（输出至一台1920x1080的限制小电视）然后一直无信号。<br>我以为是系统出了问题，重新试了好多次都一直是无信号，最终在YouTube上看到了解决方案：  </p><ul><li><strong>Solve</strong>  <ol><li>将SD卡连至电脑，打开FAT32分区里面的<code>config.txt</code>文件  </li><li>更改/添加 以下配置： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#强制使用HDMI输出</span><br><span class="line">hdmi_force_hotplug&#x3D;1</span><br><span class="line"></span><br><span class="line">#HDMI信号增强</span><br><span class="line">config_hdmi_boost&#x3D;4</span><br><span class="line"></span><br><span class="line">#HDMI输出适配于计算机显示器</span><br><span class="line">hdmi_group&#x3D;2</span><br><span class="line"></span><br><span class="line">#HDMI输出的分辨率及刷新频率</span><br><span class="line">hdmi_mode&#x3D;9</span><br><span class="line"></span><br><span class="line">#禁止树莓派检测显示器分辨率，直接使用配置文件中制定的分辨率输出</span><br><span class="line">hdmi_ignore_edid&#x3D;0xa5000080</span><br><span class="line"></span><br><span class="line">#禁止黑边</span><br><span class="line">disable_overscan&#x3D;1</span><br><span class="line"></span><br><span class="line">附：常用的分辨率配置</span><br><span class="line">hdmi_mode&#x3D;4    640x480   60Hz</span><br><span class="line">hdmi_mode&#x3D;9    800x600   60Hz</span><br><span class="line">hdmi_mode&#x3D;16   1024x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;23   1280x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;32   1280x960  60Hz</span><br><span class="line">hdmi_mode&#x3D;35   1280x1024 60Hz</span><br><span class="line">hdmi_mode&#x3D;39   1360x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;47   1440x900  60Hz</span><br><span class="line">hdmi_mode&#x3D;81   1366x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;82   1920x1080 60Hz</span><br></pre></td></tr></table></figure></li><li>保存、重新插上Raspberry Pi，重新开机，点亮</li></ol></li></ul><h3 id="2-Wifi"><a href="#2-Wifi" class="headerlink" title="2. Wifi"></a><strong>2. Wifi</strong></h3><p>我当前使用的<code>NetworkManager</code>，因为是很久前配置的开机自动连接wifi，导致忘了是如何设置得了，今天补一下  </p><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><ul><li><p>NetworkManager定期扫描Wi-Fi网络,使用<code>nmcli dev wifi list</code>可以查看最近一次的扫描结果</p></li><li><p>若无法看见要连接的SSID，可以使用<code>nmcli dev wifi rescan</code>，然后再重新<code>list</code>一下</p></li></ul><h5 id="连接Wifi"><a href="#连接Wifi" class="headerlink" title="连接Wifi"></a>连接Wifi</h5><p>使用<code>sudo nmcli dev wifi connect &#39;SSID&#39; password &#39;mypassword&#39;</code></p><h5 id="检查设备状态"><a href="#检查设备状态" class="headerlink" title="检查设备状态"></a>检查设备状态</h5><p>使用<code>nmcli dev status</code></p><h5 id="检查活动连接"><a href="#检查活动连接" class="headerlink" title="检查活动连接"></a>检查活动连接</h5><p>使用<code>nmcli con show --active</code></p><h5 id="删除已建立的连接"><a href="#删除已建立的连接" class="headerlink" title="删除已建立的连接"></a>删除已建立的连接</h5><p>如果需要删除已建立的连接，则可以指定连接UUID或连接名称，要获得连接UUID或用户名，运行<code>nmcli con</code>显示</p><ul><li>使用连接名称连接删除<br><code>sudo nmcli con del &#39;SSID&#39;</code></li><li>使用连接UUID删除连接<br><code>sudo nmcli con del xxx-xxx-xxx-xxx-xxx</code></li></ul><h5 id="还可以使用下面的命令来关闭或打开以前的连接"><a href="#还可以使用下面的命令来关闭或打开以前的连接" class="headerlink" title="还可以使用下面的命令来关闭或打开以前的连接"></a>还可以使用下面的命令来关闭或打开以前的连接</h5><p><code>nmcli con down</code><br><code>nmcli con up</code></p><hr><h2 id="网络连接问题"><a href="#网络连接问题" class="headerlink" title="网络连接问题"></a>网络连接问题</h2><p><del>待更新，不断补齐，咕咕咕</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我也要和TCP握手</title>
      <link href="article/tcp/"/>
      <url>article/tcp/</url>
      
        <content type="html"><![CDATA[<p>迎新真好笑，还是充实自己<br>多次在网上看见面试时问到的TCP三次握手问题，都是看了个大概罢了，这两天好好理解了一下<br><a id="more"></a></p><h1 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h1><blockquote><p>TCP（Transmission Control Protocol）全称：传输控制协议  </p><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议.<br>TCP 要求在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等.</p><h2 id="TCP长啥样"><a href="#TCP长啥样" class="headerlink" title="TCP长啥样"></a>TCP长啥样</h2><p><em>注：主要是TCP报文头部</em><br><strong>如下图：</strong><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E6%8A%A5%E5%A4%B4.png" alt="TCP报头"></p></blockquote><p>其中：  </p><ul><li><p>源端口和目的端口：各占2个字节(16位)，分别写入源端口和目的端口.</p></li><li><p>序号：占4个字节(32位)，序号是本报文段发送的数据组的第一个字节的序号。TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 100 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从200开始。序号确保了TCP传输的有序性.</p></li><li><p>确认号(即ACKnum)：占4个字节(32位)，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。</p><blockquote><p>例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确地收到了A发送的直到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701.<br>确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0.</p></blockquote></li><li><p>首部长度/数据偏移：占4位(32位)，它指出TCP报文的数据距离TCP报文段的起始处有多远</p><blockquote><p>由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值.</p></blockquote></li><li><p>保留：占6位，保留今后使用，但目前应都位0.</p></li><li><p>紧急URG：占2字节(16位)，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据.</p></li><li><p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。TCP规定，在<strong>连接建立后所有报文的传输都必须把ACK置1</strong></p></li><li><p>推送PSH：占1位，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p></li><li><p>复位RST：占1位，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p></li><li><p>同步SYN：占1位，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</p></li><li><p>终止FIN：占1位，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</p></li><li><p>窗口：占2字节(16位)，指的是通知接收方，发送本报文你需要有多大的空间来接受；</p></li><li><p>检验和：占2字节(16位)，校验首部和数据这两部分；</p></li><li><p>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</p></li><li><p>选项，长度可变，定义一些其他的可选的参数。</p></li></ul><p><strong>一系列数据下来，TCP的首部固定为20字节</strong></p><h2 id="运作方式"><a href="#运作方式" class="headerlink" title="运作方式"></a>运作方式</h2><p>介绍完了TCP，我们来看一下TCP的三个阶段，<br>TCP协议的运行可划分为三个阶段：  </p><ol><li>连接创建(connection establishment)</li><li>数据传送（data transfer）</li><li>连接终止（connection termination)  </li></ol><p>这篇文章主要叙述的是 <strong>连接创建</strong>与<strong>连接终止</strong> 两个阶段，也就是TCP的三次握手与四次挥手两个环节.</p><h2 id="创建通路-三次握手：Three-way-handshake"><a href="#创建通路-三次握手：Three-way-handshake" class="headerlink" title="创建通路(三次握手：Three-way handshake)"></a>创建通路(三次握手：Three-way handshake)</h2><ul><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，服务器就进入了 <code>LISTEN</code> 状态</li></ul><ol><li><p><strong>第一次握手(SYN=1, seq=x):</strong><br> TCP客户进程也先创建传输控制块TCB，然后向TCP服务器发出连接请求报文。  </p><p> 这时报文首部中的同部位 <code>SYN=1</code>，同时选择一个初始序列号 <code>seq=x</code>，此时，TCP客户端进程进入了 <code>SYN-SENT（同步已发送状态）</code> 状态。  </p><p> TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p></li><li><p><strong>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</strong><br> TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1</code>，<code>SYN=1</code>，确认号是<code>ACKnum=x+1</code>，同时也要为自己初始化一个序列号 <code>seq=y</code>。  </p><p> 此时，TCP服务器进程进入了<code>SYN-RCVD（同步收到</code>）状态。这个报文同样不能携带数据，而且要消耗一个序号。</p></li><li><p><strong>第三次握手(ACK=1，ACKnum=y+1)</strong><br>TCP客户进程收到确认后，还要向TCP服务器给出确认。确认报文的<code>ACK=1</code>，<code>ACKnum=y+1</code>，自己的序列号<code>seq=x+1</code>.  </p><p> 此时，TCP连接建立，客户端进入<code>ESTABLISHED（已建立连接）</code>状态。  </p><p> TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p></li></ol><ul><li><p>当服务器收到客户端的确认后也进入<code>ESTABLISHED</code>状态，此后双方就可以开始通信了</p><h3 id="TCP为何要三次握手，两次呢"><a href="#TCP为何要三次握手，两次呢" class="headerlink" title="TCP为何要三次握手，两次呢"></a>TCP为何要三次握手，两次呢</h3><ul><li>为什么TCP需要三次握手？如果只有两次呢？后果是什么？<blockquote><p>如果使用两次握手有可能会出现这种情况：<br>客户端发送第一次的连接请求后，因为连接请求报文丢失而未收到确认，所以再次发送了一次请求，最后这次请求成功建立，并在数据传输完成后释放连接。<br>如果第一次的连接请求只是在某个网络节点上滞留了一段时间且在第二次连接释放以后的某个时间才到达服务端，造成服务端误以为是客户端发起的新的请求，于是向客户端发出确认报文段，同意建立连接(未采用三次握手)，新的连接又再次建立，此时客户端忽略服务端发来的确认，也不向服务端发送数据，造成服务端一直等待客户端发送数据，浪费大量服务端资源.</p></blockquote></li></ul></li></ul><h2 id="终结通路-四次挥手-Four-way-handshake"><a href="#终结通路-四次挥手-Four-way-handshake" class="headerlink" title="终结通路(四次挥手 Four-way handshake)"></a>终结通路(四次挥手 Four-way handshake)</h2><p><strong>四次挥手也称作改进的三次握手，客户端或者服务器均可发起主动挥手动作</strong></p><ul><li><p><strong>第一次挥手(FIN=1，seq=x)</strong><br>假设客户端想要关闭连接，可以向服务端发送一个报头FIN=1的包，表明自己已经没有数据可以发送了，但是仍可以接收数.  </p><p>发送完毕后客户端进入 <code>FIN_WAIT_1</code> 状态,</p></li><li><p><strong>第二次挥手(ACK=1，ACKnum=x+1)</strong><br>服务器端确认客户端的 FIN 包，发送一个确认包，报头<code>ACK=1</code>，<code>ACKnum=x+1</code>，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接.  </p><p>  发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p></li><li><p><strong>第三次挥手(FIN=1，seq=y)</strong><br>服务器端准备好关闭连接时，向客户端发送结束连接请求，报头<code>FIN=1</code> .</p><p>  发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK.</p></li><li><p><strong>第四次挥手(ACK=1，ACKnum=y+1)</strong><br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 <code>ACK</code> 包。</p><p>  服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><blockquote><p>如果客户端等待了某个固定时间（两个最大段生命周期，<code>2MSL</code>，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p></blockquote></li></ul><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p><strong>四次握手中也有问题，比如最后一次握手后，主动提出断开连接的一方需要再等候<code>2MSL</code>，为什么？</strong>  </p><blockquote><p>我们再看一遍简化的四次挥手：  </p><ol><li>首先主动发起断开连接请求的A向服务端发送<code>FIN=1</code>的报文</li><li>服务端收到A的报文，回复<code>ACKnum</code></li><li>等待一段时间，B发出<code>FIN=1</code>的报文<br>此时B还不能释放资源，因为它需要确认A收到了<code>ACKnum</code>与<code>FIN=1</code>，所以还需要等待A发送的最后一个消息：<code>ACKnum</code></li><li>A发出最后一条消息，B成功收到  </li></ol><ul><li>当B收到A最后发来的消息时：<br>在B的视线内B认为双方已经达成了同步，都可以释放资源并关闭连接了，此时B释放此次TCP连接占用的资源以及端口。所以B(服务端)无需产生wait time，直接释放.</li></ul></blockquote><ul><li>但在A看来，发出最后一条消息后，因为已经是四次挥手的最后一次，所以A没有办法确认B是否收到了这条消息，所以A会做出两种假设：  <ol><li>B没有收到<br> B会超时重新传递FIN，A接受到后，会重新发送ACKnum</li><li>B收到了<br> 不会回复任何消息，需要一个相对安全的wait time确保B已经收到  </li></ol></li></ul><blockquote><p>出现的A等待<code>2MSL</code>就是取这两种情况等待时间的最大值，以应对最坏情况，来确保TCP连接的正常关闭<br><strong>最坏情况就是:去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL) = 2MSL</strong></p></blockquote><ul><li><p>等待<code>2MSL</code>后，A就可以安心释放TCP占用的资源、端口。如果不等：  </p><p>  释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部失效。</p></li></ul><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul><li><p>什么是SYN攻击<br>在三次握手中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 ACK 之前的 TCP 连接称为<code>`半连接(half-open connect)。此时服务器处于</code>SYN_RCVD<code>状态。当收到 ACK 后，服务器才能转入</code>ESTABLISHED` 状态.</p><p>SYN 攻击指攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。<br>由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>  SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></li><li><p>怎么检测SYN攻击<br>如果在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p></li><li><p>如何防御 SYN 攻击<br>SYN攻击不能完全被阻止，除非将TCP协议重新设计。但可以减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重庆三日游</title>
      <link href="article/travle/"/>
      <url>article/travle/</url>
      
        <content type="html"><![CDATA[<p>2020-7-21~23的重庆三日游已经结束啦！<br>记录下我们的行程和去重庆的回忆.<br><a id="more"></a></p><h1 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h1><p><del>2020-7-21~23会去重庆旅游三天，现在正在规划行程呢，选了一些景点和小店，留在这儿看方便一点。<br>后续还会添加一些地点Maybe，还会更新出完整的重庆游方案以及部分照片</del>。</p><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><ul><li><strong>千厮门大桥</strong></li><li><strong>洪崖洞</strong><br><em>Location:重庆市渝中区嘉陵江滨江路88号</em></li><li><strong>龙门浩老街</strong><br><em>Location:南滨路105号</em></li><li><strong>解放碑</strong><br><em>Location:邹容路100号</em></li><li><p><strong>白象居</strong><br><em>Location: 渝中区白象街1-6号</em></p></li><li><p><strong>来福士广场</strong><br><em>Location： 渝中区铁板巷6号</em><br><em>Pic： 渝中区铁板巷8号</em>  </p></li></ul><hr><h2 id="探店"><a href="#探店" class="headerlink" title="探店"></a>探店</h2><ul><li><p><strong>三浮冰事</strong><br><em>Location：重庆市渝中区大坪正街大坪龙湖时代天街D馆12栋1楼</em></p></li><li><p><strong>Mist Castle</strong><br><em>Location:重庆市渝中区大坪正街大坪龙湖时代天街B馆4号楼14-16</em></p></li><li><p><strong>Wormhole Vintage</strong><br><em>Location：大坪正街大坪龙湖时代天街A馆时代星空1栋1224</em></p></li><li><p><strong>The Place食也·灶咖</strong><br><em>Location：黄龙路朗俊中心4幢1-商业9(豪谛酒店对面)</em></p></li><li><p><strong>失重餐厅</strong><br><em>Location:来福士广场商场四层001号</em></p></li><li><p><strong>饭粑砣</strong><br><em>Location：较场口89号得意世界c区1-2号</em></p></li></ul><hr><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><ul><li><p><strong>长江索道</strong><br><em>Location：新华路151号</em></p></li><li><p><strong>探索舱·观景台</strong><br><em>Location：接圣街8号(重庆来福士14号门)</em>  </p></li></ul><hr><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><ul><li><strong>Day1.<br>到达后：下高铁——午餐——民宿(3pm)<br>下午：三浮冰事——Wormhole Vintage——Mist Castle<br>晚餐：寿喜烧<br>晚上：逛街</strong></li><li><p><strong>Day2.<br>早上：解放碑逛街<br>午餐：饭粑砣<br>下午：白象居拍照——长江索道——龙门浩老街拍照<br>晚餐：龙门九号火锅<br>晚上：洪崖洞、千厮门大桥——回民宿</strong></p></li><li><p><strong>Day3.<br>早上：来福士广场<br>午餐：失重餐厅<br>下午：探索舱·观景台———朝天门广场<br>晚餐：the place食也·灶咖<br>晚上：动车回家</strong></p></li></ul><hr><h1 id="详细感受"><a href="#详细感受" class="headerlink" title="详细感受"></a>详细感受</h1><p>此板块下分为了对重庆的各方面感受，还有旅行中的感受 .</p><h2 id="1-天气方面"><a href="#1-天气方面" class="headerlink" title="1. 天气方面"></a>1. 天气方面</h2><ul><li>说实话刚到重庆时的闷热是能明显感受到的，虽然当天没有出太阳是晴天，但是能明显感受到没有阵阵自然风吹来，整个的感受就是闷热。<br>前两天（21、21）的天气情况对外乡人来讲都还可以，不是很热，但是第三天气温回升的重庆还是让我们体验了一把重庆的热。第三天的天气在傍晚的时候也发生了变化，我们出 来福士 的时候下起了大雨，还不得不在Miniso买了两把雨伞。走到室外时，那种感受我承认是第一次，滚烫的地板刚沾了难得的雨水，街道上到处都散发着一股闷的味道，很是难忘。</li></ul><h2 id="2-人文方面"><a href="#2-人文方面" class="headerlink" title="2. 人文方面"></a>2. 人文方面</h2><ul><li>重庆人给我的第一感受就是：野性、豪爽，那边的口音能让我听着有一种亲切感，因为我老家的口音和重庆口音比较类似，交流起来也不需要用普通话，比较方便。  </li></ul><h2 id="3-饮食方面"><a href="#3-饮食方面" class="headerlink" title="3. 饮食方面"></a>3. 饮食方面</h2><ul><li>其实川渝地区的口味都相差不是很大，我们同行的人都比较能吃辣，应付重庆的菜不在话下</li></ul><h2 id="4-住宿方面"><a href="#4-住宿方面" class="headerlink" title="4. 住宿方面"></a>4. 住宿方面</h2><ul><li>去外地城市旅游首选肯定是民宿了，这次的民宿找了两天，终于选定了一家有3卧、临江还便宜的民宿。<br>不过肯定有一些缺点，首先是民宿有一点老旧，其中的一些小细节方面体验不是非常好，比如所卫生间设计的有点奇怪，卧室的被套上有一些水臭，除了这些外整体体验都非常不错。<br><del>（2晚每个人付200左右，不要太便宜）</del></li></ul><h2 id="5-城市印象"><a href="#5-城市印象" class="headerlink" title="5. 城市印象"></a>5. 城市印象</h2><ul><li>8D!8D!8D!<br>在重庆最让我疑惑的问题是“我在第几层”，从我们的第一楼爬了一段很高的楼梯，上去后告诉我是在-3楼…<br>从我们的第一楼进去后看路标是在4楼…<br>呜呜呜呜呜！老千层饼了</li></ul><h1 id="相关照片"><a href="#相关照片" class="headerlink" title="相关照片"></a>相关照片</h1><p><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E5%A4%A7%E6%A1%A5.jpg" alt="东水门大桥"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E5%88%A8%E5%86%B0.jpg" alt="三浮冰事"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E5%B0%8F%E5%90%83.jpg" alt="小吃"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E9%85%B8%E5%A5%B6.jpg" alt="酸奶"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E9%A5%AD.jpg" alt="食也">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 旅行日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现在由Sheey帮我托管博客啦</title>
      <link href="article/update/"/>
      <url>article/update/</url>
      
        <content type="html"><![CDATA[<p>困扰了许久的问题终于解决了<br><a id="more"></a></p><h2 id="gt-前言：有时候和Sheey聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。"><a href="#gt-前言：有时候和Sheey聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。" class="headerlink" title="&gt; 前言：有时候和Sheey聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。  "></a>&gt; 前言：有时候和<a href="https://sheey.moe">Sheey</a>聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。  </h2><ul><li><p><a href="https://codgi.xin">Codgi的小窝</a>在Github上开启了静态页面托管，奈何隔了半个地球的服务器对大陆地区一部分用户不友好，遂换到了鹅厂的Coding托管，这下访问速度不成问题了，但是出现了隔三岔五的就会访问不上。</p></li><li><p>最近<a href="https://sheey.moe">Sheey</a>提出来了帮我托管，在犹豫了半天后发现访问还是有问题，最后实在忍不了了就让他帮我托管啦，这下访问就没有问题了，蟹蟹 <a href="https://sheey.moe">Sheey</a> 大佬的帮助.  </p></li></ul><p>遇到的问题：这篇文章是在<a href="https://sheey.moe">Sheey</a>帮我托管后所发的第一篇文章，当天已经很晚了，我使用<code>hexo g -d</code>后发现没有及时更新，<a href="https://sheey.moe">Sheey</a>大佬告诉我是5mins抓取一次，索性也就没管了。  </p><p>几天后我发现还是没有更新，然后找到了<a href="https://sheey.moe">Sheey</a>，一番排查后发现这个问题也是他曾经遇到过的…——&gt;<a href="https://sheey.moe/article/build-blog-online">在服务器上持续化 build blog</a></p><p>最终提出的发布方案：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">cd public</span><br><span class="line">git add</span><br><span class="line">git commit -m &#x27;update&#x27;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><br>测试后没有问题了<br><strong>以上</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>赚钱 Or 学习</title>
      <link href="article/makemoney/"/>
      <url>article/makemoney/</url>
      
        <content type="html"><![CDATA[<p>大学生活已经过去了一年，由于特殊的疫情，今年我们不得不在家待了半年，很多同学借着此次机会，外出兼职、打工、摆地摊，也是<br>赚到了人生中的第一桶金。我也不例外，赚到了人生的第一桶金：x RMB，量级为K，但是却跟他们不一样，这次写写大学生赚钱那些事。<br><a id="more"></a></p><h1 id="大部分的赚钱方式"><a href="#大部分的赚钱方式" class="headerlink" title="大部分的赚钱方式"></a>大部分的赚钱方式</h1><p>打开知乎，搜索框内键入“赚钱”关键字，然后回车，你所看到的答案清一色的有以下几种：网赚、写手、二手、投稿、自媒体、问答、问卷、App体验。<br>各种回答把上面的几种赚钱方法吹得神乎其神，放几张自己存款的截图，然后就硬吹，赚钱方法人家会选择自己最合适的，但是坑却不会告诉你。</p><hr><h2 id="靠网赚"><a href="#靠网赚" class="headerlink" title="靠网赚"></a>靠网赚</h2><p>这种赚钱方式我不想聊，很多，比如淘宝刷单类、淘宝客类、做网络直播、短视频类等，但是结合一下自身的实际情况，有多少大学生是符合这个网赚的要求的？<br>还有说打字就能赚钱的，要真这么简单他为啥会给你做呢？<br><strong>有赚到钱的，但是不固定</strong></p><h2 id="做写手"><a href="#做写手" class="headerlink" title="做写手"></a>做写手</h2><p>在淘宝找个店家，然后私聊客服说可以做写手，又或者专门加那种写手的QQ群。要加入他们当一名写手你需要经过如下过程：  </p><ol><li>通过他们设计的考试（设计的考试很扯淡，而且通过率很低</li><li>叫你先写几份文稿看下</li><li>（可能会叫你交入会费）</li></ol><p>如果你成功加入了他们，开始了你的写手“赚钱”日子，你发现做一名写手好像没那么容易赚钱。<br>首先不谈写手的效率问题，有哪个业余的写手能保证自己拿到单子后都有明确的思路和写出很好的文章，大部分招写手的都是有任务后发给写手做，然后筛选出比较好的文章交工。<br>如果你文采足够好，恰好脱颖而出了一下，结账的时候发现自己当了黑奴：1000字20~50rmb，然后又会百般刁难你，最后你拿到的钱就只有那少少的几十块，几乎是做了免费的劳动力，赚钱全是人家的。  </p><p><em>如果这条你不信的话可以去亲身体验下</em>  </p><h2 id="卖闲置"><a href="#卖闲置" class="headerlink" title="卖闲置"></a>卖闲置</h2><p>敢问在座的学生党家里具体有多少闲置的物品，许多年前的手机、数码产品、过时的小物品，放在咸鱼上其实是买不到多少钱的。而且在家闲置的物品说不定你哪个时候还能用上，靠卖二手物品不能算作真正意义上的“赚钱”，而是用一物换一物。  </p><p>看到这儿许多人又会问了：我去薅羊毛、捡垃圾，然后再把这些东西在二手平台上卖掉，不是还是可以赚钱吗，而且基本是原价赚。确实是现在大多数人把赚钱想得太简单了，铺天盖地的什么“神车群”、“捡漏群”让你加。那事实是什么呢： </p><ol><li>群里会有真正的“神车”，但是你未必能抢到，需要时不时就看一下消息</li><li>群里面发的几分钱几角钱抢一个很高价的物品的图大概率是P的</li><li>群内的推送不是真正的BUG、漏洞，而是和商家联系好了的推广链接</li></ol><p>现在都不流行薅羊毛了，喜欢薅薅羊毛的人，进群发现要蹲的东西都没有，买了几个盗版、杂牌货还以为自己赚了，卖不出去还给人家赚了佣金。也不想想为什么这种群还需要推广，如果真的如他们说的那么美好，岂不是自己闷声发大财。<br>家里如果不是真有不用的闲置物品，或者你想靠薅羊毛倒卖赚钱的话还是打消这个想法吧。</p><h2 id="瞎投稿"><a href="#瞎投稿" class="headerlink" title="瞎投稿"></a>瞎投稿</h2><p>跟写手一个性质，不过这个更像以后你投出去的简历没了后续  </p><h2 id="自媒体"><a href="#自媒体" class="headerlink" title="自媒体"></a>自媒体</h2><p>这里指的头条号、企鹅号、大鱼号等自媒体网站，这里真的别做了，到现在这个阶段你一个人没法做了，而且成不了的，看一下网上整理出来的数据吧：</p><blockquote><p>头条号：1W阅读量 1元 （量大，一般一篇文章能有几千的阅读）<br>企鹅号：1W阅读量 1元 （量小，一般一篇文章阅读量只有几百）<br>大鱼号：1W阅读量 1.5-2元 （量小，一般一篇文章阅读量只有几百）<br>百家号：1W阅读量 10-15元 （量中，一般一篇文章阅读量几百到几千，开通收益条件苛刻）  </p></blockquote><p>现在的基本情况就是做自媒体的人比看自媒体的人都还多，还怎么玩？  </p><h2 id="填问答、问卷"><a href="#填问答、问卷" class="headerlink" title="填问答、问卷"></a>填问答、问卷</h2><p>可能大部分人还不知道这个也可以赚钱，也是，问题搜都搜不出来、答对了的回报还少，还有许多工作室的存在，从人家嘴巴里抢肉还是嫩了点。<br>常见的问答平台的报价：</p><blockquote><p>悟空问答：现在基本没有收益了<br>芝麻问答：回答一个问题0.2元，一个月开原创后2元，原创需要300字加图片<br>How问答：回答一个问题0.5元，回答需要审核，通过率很低，审核速度巨慢  </p></blockquote><p>上面的我也亲自去做过一次，当时还没遭受过毒打，以为去网上搜一下就能轻松地赚到钱，结果现实给了我迎头一棒。</p><h2 id="下App"><a href="#下App" class="headerlink" title="下App"></a>下App</h2><p>众人帮、赚钱了等等App，本质就是你下载App赚钱，你可知道下载一个只有0.05-0.2元，不仅如此还需要注册体验3分钟才行，这钱真的有赚的价值和必要？？不仅如此，提取现金还需要门槛，门槛很高，也是30元才能提取现金，是真难做。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面写的几种常见的赚钱方法的真实面目可能会打击你赚钱的信心，但是现实就是这样，网上赚钱方法遍地走，就仿佛在逛90年代的香港，遍地是黄金，满街都是女人。<br>真正的赚钱方法永远是掌握在真正赚钱的人的手中，这么可能会随随便便就分享给网上素不相识的人，如果有那真是脑袋抽了，自己给自己找对手。<br>真正赚到钱的人都是有恒心自己去把答案找出来的那些人。<br>别人的答案帮不了你，你得自己花时间。  </p><h2 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h2><p>好好学习</p><p>国奖：8000</p><p>励志奖学金：5000</p><p>一等奖学金：1500</p><p>三好与优干：1000</p><p><strong>学习好在大学以前是省钱，上大学后学习后确实赚钱</strong><br><strong>或者给自己培养个兴趣，找到合适的机会将自己的技能或者知识变现也是个不错的选择</strong><br><strong>如果硬要我选，学习真tm香</strong>  </p><p>灵感来源：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=57285232&bvid=BV1gx411R7ke&cid=99998982&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哪个男孩不想要好用的网盘</title>
      <link href="article/clouddrive/"/>
      <url>article/clouddrive/</url>
      
        <content type="html"><![CDATA[<p>pandownload的作者前几天的时候刚被抓捕，法律规定模糊不清，没有审判标准，直接定罪。<br>做一款好的云盘究竟有多难？<br><a id="more"></a></p><h1 id="网盘那些事"><a href="#网盘那些事" class="headerlink" title="网盘那些事"></a>网盘那些事</h1><h2 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>绝大部分数据是存放在数据中心内的，一个典型的数据中心内，你可以看到一排排机柜，机柜里是机架式服务器，服务器里插着硬盘，存放的文件就在这里面<br>服务器是数据中心的基本单位，每台服务器都有独立的CPU和内存，以及其他必须硬件，用于接收上传和下载请求。</p></li><li><p>衡量一台服务器大小的单位是U，常见的尺寸有1U、2U、4U，每1U表示服务器的高度是4.445cm，当然，尺寸越大装的硬盘也就越多。<br>每台机柜的高度大部分是42U，能够并排放进16台1U的服务器，数据中心里每100平方米可以放进20台机柜，这样每100平方米<br>可以放下20x16x4x8 差不多1万 TB的硬盘</p></li></ul><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><ul><li><p>如果这台服务器只服务于极少数的人，那么要实现不难<br>难的是在成千上万个人同时下载的时候，还能够保持高速，这时就需要将文件分块,<br>比如一个大小1G的文件，我们可以切分成1024块1M大小的文件块，分布到多台服务器内</p></li><li><p>当接受到下载请求后，数据中心首先会访问元数据服务器，反馈出下载对象储存在哪些服务器内<br>然后用户会直接访问相应服务器内的相应内容，读取数据，但是仅仅这样做还是不够</p></li><li><p>今天，云存储服务还都提供了CDN支持，<br>CDN相当于你和数据中心之间的缓存，能够极大的缓解数据中心的压力</p></li></ul><h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><blockquote><p>不仅仅是网盘，我们访问的绝大多数服务器都需要数据中心的支持，我们可以在百度、腾讯、阿里云等提供云服务平台上<br>详细的找到他们对于数据存储的定价，大概的价格是0.15元/GB/月，按照这个价格可以算出来存储1T的数据一年旧的花1800元<br>为什么价格这么高，首先我们需要知道数据中心主要有哪些开销</p></blockquote><ol><li><p>硬件成本<br> 以百度阳泉数据中心为例，里面共有16万台服务器，总共可以存储大概6000 PB，也就是614万 TB的数据，假设都使用8TB x 18<br> 规格的存储服务器，则将近会使用4.27万个存储服务器，按每块8TB 硬盘2000，每台服务器一万元来粗略计算，光是前期投入的硬件<br> 成本就得19.6亿元，换算一下就是319.5元/TB</p></li><li><p>电费开销<br> 即使是在<strong>非常节能</strong>的“北极”整机柜中，每6台服务器就需要1个2400W的电源进行集中供电，那么该数据中心每小时就<br> 要消耗6.4万度电来运转所有的服务器，按照阳泉市0.45元/度 的商业用电标准，一年的电费还会烧掉2.5亿元</p></li><li><p>还有网费<br> 数据中心为了提供云存储服务，需要向三大运营商缴纳约10万元/GB/月的专线接入费用，按中国数据中心的平均出口带宽<br> 332GB来计算，每年还要缴4亿的网费</p><p><strong>这样看来，提供云存储服务是真的很贵，不算上初次投入以及其他花销，每年光是电费网费就得6.5亿元</strong></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>不考虑每年的硬件损耗，阳泉数据中心每存储1TB 的数据，每年在电费和宽带上的钱也需花费105.7元/TB</p></li><li><p>高额的运营成本，让很多的网盘服务都纷纷倒闭，目前的网盘收费方式主要有购买空间和购买会员两种方式<br>iCloud和Dropbox是典型的空间购买型网盘，2TB空间每年要花费816元人民币</p></li><li><p>如果不想花这么多钱，你也可以选择免费都有2TB的百度网盘，但免费也有免费的问题，无论你家网速多块，只要不是会员都会被限速下载，<br>毕竟服务商也是要赚钱的</p></li><li><p>以阳泉数据中心为例，即使每年交4亿元网费，在不限速的情况下，332GB的带宽也只能够支持6W人以700K每秒<br>的速度下载，非常紧张，如果保证有1W名会员能够以3.9M每秒的速度下载，剩下的免费用户的下载速度只有50K每秒了<br>这样节约了成本，也增加了付费点: 充值会员开启高速下载，毕竟每1TB的运营成本就得106元，如果不想想办法的法就只能像其他<br>网盘一样倒闭了</p></li></ul><h2 id="百度云盘"><a href="#百度云盘" class="headerlink" title="百度云盘"></a>百度云盘</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>百度网盘，曾用名百度云（Baidu Cloud），是百度推出的一项个人云存储服务，覆盖中国大陆各大主流电脑和手机操作系统，包含Web版、Windows版、Mac版、Android版和iPhone版。用户可以将自己的文件上传到网盘上，并可跨终端查看和分享。在百度创建开放云后，合并为平台分布式私人储存服务。当前，百度网盘已成为了中国大陆最大的网盘服务商之一</p></blockquote><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p><strong>评价分为正反两方面</strong></p><ul><li><p>正面:</p><p>百度网盘免费提供2TB网盘空间，支持网盘之间好友相互共享文件，并且支持离线下载，受到用户的欢迎与使用</p></li><li><p>负面:</p><ol><li><p><strong>用户隐私问题</strong></p><p> 2017年7月18日，自媒体用户发文称，因为用户通过百度网盘公开分享的文件可以被所有人任意阅览与下载，所以在一些第三方网盘搜索网站上也可以搜索到这些文件，其中就有网盘用户通过公开方式分享的个人照片、通讯录等涉及个人信息的文件，这也造成了一定程度上用户隐私泄露的隐患</p></li><li><p><strong>净网行动</strong></p><p> 因为百度网盘的文件分享功能便利，不少用户利用其传播一些在中华人民共和国的境内网站受到限制的内容，例如色情内容，因此百度网盘曾经被中国大陆相关部门约谈。自2014年起，百度网盘几乎每年都响应中华人民共和国全国“扫黄打非”工作小组办公室主办的“净网”专项行动，对用户上传的文件进行自我审查，删除某些在中国大陆境内的受限内容</p><blockquote><p>百度网盘将对用户上传、存储、分享的色情淫秽、暴恐等不良信息以及涉侵权的文件继续加大清理力度。对于相关的不良信息及严重违规账号，将采取全面清理、永久封禁的措施</p></blockquote><p> 2014年的扫黄打非·净网2014期间，很多用户发现自己网盘中的一些视频被替换成“8秒百度云净网行动公告”（俗称“8秒教育片”），被替换的视频大部分是涉黄视频，也包含其他类型的视频。不少用户抱怨百度网盘未尽保护用户上传数据隐私的责任。为了绕过审查机制还出现了一些新的上传手段</p></li><li><p><strong>下载限速</strong><br> 百度推出“超级会员”开始，便陆陆续续有用户反映百度网盘限制了普通用户和普通会员用户的下载速度<br> <strong>而百度网盘官方否认这种行为，在百度网盘的FQA中，出现过以下内容：</strong></p><blockquote><p>Q:使用百度网盘PC客户端下载\上传遇到失败、中断、速度慢、路径无效、无权限，怎么办？<br>A:网盘客户端上传下载速度均未做任何限速，原则上速度取决您带宽大小</p></blockquote><p> <strong>这也是后面a发生事情的开端</strong><br> 部分用户因此抨击百度网盘，亦有不少用户因此开发了各种尝试破解百度网盘限速的方式。对此，2018年4月，百度网盘采用了封杀非官方版本的方式进行应对，使用非官方版本下载网盘文件，将会出现失败的情况。更进一步的，如果帐号存在大量异常请求，将会被锁定</p></li><li><strong>部分地区的服务限制</strong><br> 百度网盘的分享链接会选择性地屏蔽部分地区的IP（例如新疆和台湾），这些地区的用户在尝试下载百度网盘分享链接中包含的资源时会跳转至链接已经失效的页面（“啊哦，你所访问的页面不存在了”）；但如果使用VPN打开分享链接，则可以正常下载</li></ol></li></ul><h2 id="Pandownload"><a href="#Pandownload" class="headerlink" title="Pandownload"></a>Pandownload</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>  Pandownload于2017年2月19日上线，是一款在百度网盘的基础下提供的不被百度认可的第三方百度网盘下载软件。PanDownload可以在Windows和Android系统上使用，另外还有Web版（仅提供解析百度网盘文件下载链接功能）。用户可以通过PanDownload实现百度网盘文件的高速下载</p><h3 id="发生事件"><a href="#发生事件" class="headerlink" title="发生事件"></a>发生事件</h3><p>  <strong>2020年4月15日，PanDownload的作者因涉嫌提供侵入、非法控制计算机信息系统的程序、工具罪被逮捕</strong></p><p>  下面是“官方版”：</p><blockquote><p>经查：2017年，犯罪嫌疑人在家中编写可以通过百度网盘官方服务器的客户端身份认证，实现以非会员权限突破百度网盘官方设定，高速下载Pandownload软件，并在互联网上发布。期间犯罪嫌疑人租用网络服务器进行更新维护并发布接受捐赠的收款码，同时建立QQ群，向进群人员收取1至10元不等的进群费，群内提供更稳定的 Pandownload内测版本。截至案发，犯罪嫌疑人非法获利30万余元</p></blockquote><ul><li>与此同时，PanDownload的官网已不可用，其Windows版软件在启动时报“http请求错误 0x1c”或“http请求错误 0x38”，Android软件启动时报“本软件已停用”</li></ul><h2 id="如何去理性看待"><a href="#如何去理性看待" class="headerlink" title="如何去理性看待"></a>如何去理性看待</h2><ul><li><p>在百度云免费提供给我们2T空间的同时(但目前听说新用户没有2T这么多)，为我们提供免费的云存储服务这件事上确实是好的，这种东西只能自己独立去思考，百度网盘到底是什么地方做错了</p></li><li><p>你可以去选择其他的云盘，而当你的好兄弟，好同学把他的资源发给你时，你发现大多数人都在用百度网盘</p></li><li><p>Pandownload 并不被认可，同时有一点激进</p></li></ul><h2 id="深入探讨下百度网盘-amp-Pandownload"><a href="#深入探讨下百度网盘-amp-Pandownload" class="headerlink" title="深入探讨下百度网盘&amp;Pandownload"></a>深入探讨下百度网盘&amp;Pandownload</h2><ol><li><p>首先，百度网盘的体验确实是很差，流氓客户端 + 不尊重用户数据隐私 + 精准限速(限速并不是什么见不得光的事情，还有不少网盘限流呢，大大方方说出来就好)</p></li><li><p>那么如果你想要体验好的网盘呢？ 上面粗略地叙述了一下iCloud和Dropbox的价格，我们再将价格细化，多加入几个云服务厂商</p><ul><li><p>苹果 iCloud：<br>折合人民币 50GB/80¥，200GB/250¥，2TB/850¥ 每年<br>（50 GB/12$ 200GB/36$ 2TB/120$）</p></li><li><p>谷歌 Google Drive：<br>折合人民币 100GB/140¥，200GB/210¥，2TB/710¥ 每年<br>（100GB/20$ 200GB/30$ 2TB/100$）</p></li><li><p>Dropbox：2TB/850¥ 每年:<br>（2TB/120$）</p></li><li><p>Mega：400GB/460¥（限流 1TB 每月），2TB/922¥（限流 2TB 每月） 每年<br>（官网提供了人民币售价）</p><p><strong>这里面有个例外：Microsoft Onedrive</strong></p></li><li>假设你跟其他人凑成了家庭版合租，那么基本上是 1TB/50¥ 每年。<br>但 Onedrive 的速度跟上面其他服务商的速度差了不少。<br>除了微软这种赔本赚吆喝的厂商之外，2TB 存储基本售价均在 700 人民币每年往上。<br>这还是建立在这些资本主义国家云计算资源比较便宜的基础之上的</li></ul></li><li><p>可能国内的云储存介绍得也不够，再展开叙述下</p></li></ol><ul><li><p>因为 2C 生意这两年一直在「提速降费」，每个月几十一百就能开一个好几百兆的宽带，导致了很多人产生了大陆带宽很便宜的错觉。<br>说到底，羊毛出在羊身上。用户的下行对应的是服务商的上行。用户的下行带宽便宜到了白菜价就意味着要把这部分成本转嫁到服务商身上。<br>反正用户网卡了不会怪运营商，而是「你这什么破网站，我家 1000Mbps 的网看个 1080p 都卡」。</p></li><li><p>拿阿里云 ECS 为例，一条 200Mbps 杭州地区商宽的价格是折后 160000 一年，平均每个月的价格是 15000 元。<br>按量计费的价格则是 0.8元/G，假设你带宽能连续跑满一周的话，你的流量钱实际上已经跟包月专线价格一样贵了。</p></li><li><p>我们再看看专门做文件分发的又拍云，文件存储 0.0043 元/GB/天，公网流量 0.5 元/GB，国内 CDN 流量 0.29 元/GB。</p></li></ul><p><strong>有了这些数据，我们简单地做下计算</strong></p><ul><li><p>前提： 假设你的网站有 2000 个用户，每时每刻都有 100 个（5%）用户是活跃用户，在进行上传和下载。<br>每个用户网盘有 300GiB 内容，每人网盘的内容 90% 为重复内容。那么总共产生了 60000 GiB 不重复的内容与 270GiB 共有内容。<br>每个月产生的数据存储费用大约是 7700 元左右。</p></li><li><p>算法：<br>按照包死带宽法，假设你是用 200Mbps 专线，每个用户在这时候也只能分到 2 Mbps 带宽，甚至看不了一个 720p 视频。<br>在这时，每个用户的成本大约在 12 元每月。</p><p>如果按照流量法，给每个用户分配 10Mbps 带宽（总带宽 1Gbps），每个月产生的流量费用接近 162000 元左右。<br>在这时，每个用户的成本大约在 85 元每月。</p></li></ul><p><strong>即使是自建机房，价格也不会便宜多少</strong></p><ol><li><p>反观百度网盘</p><ul><li><p>百度云的定价大约是 SVIP 200 元左右一年，2TB 存储空间，实际上这个价格非常便宜，甚至接近亏本。<br>所以这可能是导致用户体验差的原因之一，毕竟钱没赚多少，亏倒是不少亏。为了保证付费用户的下载权利，只能削减免费用户的带宽</p></li><li><p>目前出现的问题也不是免费用户了，有很大一部分人是购买了百度网盘的会员奔着去使用的，但是也出现了速度不够的问题，只能简单地判断，百度云盘是否渐渐满足不了我们这么多人的需求？</p></li></ul></li><li><p>那么我们看看Pandownload</p><ul><li>极低的价格，获得的下载速度很理想</li><li>这也是个问题，如果一个「破解加速器」收费赚钱的话，更像是屠龙的勇士最终变成了恶龙，而且屠龙的剑还是白嫖的</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为一个普普通通的使用者，我两款软件都有用过，但期间有一段时间Pandownload无法使用，百度网盘我也不想使用，所以想起了自己搭建一个Oneindex，对接onedrive，目前……也用不了了<br>对于这两个软件的看法还得自己去主观判断<br>关于Pandownload作者被抓这件事也是给了各位开发者一个警告，希望在不久以后百度网盘更好用，或者会有更好的网盘商</p><p><em>文章内容一部分摘抄自<a href="https://www.bilibili.com/video/BV1Ex411f7r4">Paperclip:中国的网盘为什么这么难用</a>和<a href="https://t.me/misakatech">科技圈的日常</a>,如有侵权请联系本人删除</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈游戏</title>
      <link href="article/games/"/>
      <url>article/games/</url>
      
        <content type="html"><![CDATA[<p>我以前也是一个网瘾男孩，总是在不该玩游戏的时候疯狂玩游戏，导致自己错过也丢失过一些东西，但现在毕业以后突然就没有网瘾了，身边发生的一些事引发了我的感想，就想写一篇关于游戏的<br>本文章包含以下元素:  </p><ul><li>介绍  </li><li>游戏可以带来什么  </li><li>游戏内的病态  </li><li>我<a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>写这篇文章的原因是因为最近玩游戏的频率大大降低了，慢慢地离开游戏后所引发的感想<h1 id="游戏的简介"><a href="#游戏的简介" class="headerlink" title="游戏的简介"></a>游戏的简介</h1><h2 id="什么是游戏"><a href="#什么是游戏" class="headerlink" title="什么是游戏"></a>什么是游戏</h2></li><li>游戏是一种基于物质需求满足之上的，在一种特定时间、空间范围内遵循某种特定规则的，追求精神需求满足的社会行为方式。游戏有智力游戏和活动性游戏之分，又翻译为 Play，Pastime，Playgame，Sport，Spore，Squail，Games，Gamest，Hopscotch，Jeu，Toy。现在的游戏多指各种平台上的电子游戏。</li></ul><h2 id="常见的游戏"><a href="#常见的游戏" class="headerlink" title="常见的游戏"></a>常见的游戏</h2><ul><li><p>RPG：全称 Role-playing game，如腾讯的《火影忍者》，目前比较火的《武林外传》手游，大型多人在线角色扮演游戏。包括一些格斗类的小游戏，都可以称为RPG</p></li><li><p>FPS：全称 First-person shooting game，第一人称射击类游戏。目前比较火爆的吃鸡游戏，很多人归为fps游戏，严格意义上划分市面上大多数吃鸡游戏应当属于第三人称射击类游戏</p></li><li><p>MOBA：全称 Multiplayer Online Battle Arena，多人在线战术竞技游戏，最著名的，Dota2，LOL</p></li><li><p>LBS：全称 Location Based Services，基于位置服务（的游戏），比较偏门，如pokemon go，属于LBS+AR玩法</p></li><li><p>RCG：全称 Racing Game 竞速游戏，如极品飞车</p></li><li><p>MSC：全称 Music Game 音乐游戏，如劲舞团、劲乐团</p></li><li><p>LVG：全称Love games 恋爱养成游戏，如秋之回忆</p></li><li><p>SPG：全称Sport games 体育运动类游戏，如FIFA2，NBA2K</p></li><li><p>AVG：全称Asymmetrical Battle Arena 非对称性对抗竞技类，如黎明杀机</p></li></ul><p><strong>#注：以上分类不完全，且列举游戏仅有一小部分</strong></p><hr><h1 id="游戏的正反两面"><a href="#游戏的正反两面" class="headerlink" title="游戏的正反两面"></a>游戏的正反两面</h1><h2 id="游戏能带给我们什么"><a href="#游戏能带给我们什么" class="headerlink" title="游戏能带给我们什么"></a>游戏能带给我们什么</h2><ol><li><strong>游戏能带给我们最多的：欢乐</strong><br>毫无疑问，游戏在大多数的青少年的成长中，是必然的存在，例如我小时候玩的赛尔号，穿越火线之类的(小学)，在当时确实给我无聊的童年生活带来了许多欢乐。</li></ol><ol><li><strong>游戏，为我们丰富了社交，打开了话题</strong><br>稍微长大一点，英雄联盟步入了我的视线，看着同学们津津乐道地叙述，以及观看他们打游戏，都让我对这款游戏产生了好奇。也是我记忆最深的一次，跟同学去小网吧打英雄联盟，<br>这款游戏给我带来的最多的就是社交，与同学之间有更多的话题，也能找到更多 <strong>“志同道合”</strong> 的朋友</li></ol><ol><li><strong>游戏能让你收获一些知识</strong><br>再到后面，你玩的游戏很少有人玩，你也找不到有人可以陪你玩，因为你玩的游戏是你喜欢的，可能是因为游戏里面的某个角色、某个剧情、或者是它的背景故事吸引着你。<br>你觉得你能从这些游戏中获取你喜欢的内容，能在某些地方开拓你的眼界，所以你玩它。</li></ol><h2 id="游戏会让我们失去什么"><a href="#游戏会让我们失去什么" class="headerlink" title="游戏会让我们失去什么"></a>游戏会让我们失去什么</h2><p>  <strong>#注：建立在过度游戏的基础上</strong></p><ol><li><p><strong>荒废学业</strong><br>这一点不需要过多地去阐述太多了，抛开你在电视上看的新闻、别人口中听说的故事，你正在看的这篇文章的作者原来就是一个十足的网瘾少年。确实因为过度地游玩游戏而在学习上荒废了太多  </p></li><li><p><strong>浪费金钱</strong><br>你是否也会为了买游戏内的一个物品，连着许多天要求自己少吃点，或者根本不吃。可能在一部分的人眼中，花自己的钱买自己想要的，i高兴就行了。我当然不能否定，因为你钱多（rich 哥nb），但是你转念想一想，这笔钱你是否可以花在更有用的地方，而不是虚拟世界中的不足谈起的一件物品</p></li><li><p><strong>影响健康</strong><br>长时间盯着屏幕，眼睛早就已经很难受了，如果你是一名资深的手游玩家，有时候还以为太过于注意，导致你的眼睛离屏幕的距离更近，久而久之视力下降是必然的问题。同时，过度地玩游戏，导致你白天晚上颠倒，经常一玩游戏就是玩到半夜，对肝肾功能也有影响</p></li></ol><hr><h1 id="游戏内的病态"><a href="#游戏内的病态" class="headerlink" title="游戏内的病态"></a>游戏内的病态</h1><p> <strong>#注：这也是我讨厌且鄙视一些游戏的主要原因</strong>    </p><ol><li><p>段位机制<br>这个机制最早被提出来的时候是因为游戏内的核心玩家，或者是高水平玩家互相对比，较量的一种方式。而你现在在任何一款对战类的游戏里面随时可以看到段位的身影，是这个机制本身就有问题吗，还是我们对它的实用出现了偏差？<br><strong>一提到某个游戏，最常见的问题就是：你什么段位</strong><br><strong>恕我直言，现在我觉得紧盯段位玩游戏的人就是傻x(理智看待)</strong><br>这是每个游戏开发商希望看到的，他们想利用这个段位机制的存在，去挑逗玩家的虚荣心，去刺激玩家、捆绑玩家。想要获得更高的段位？在别人面前秀一把？你就得每天不停地在这个游戏里面努力、投入精力去玩  </p><ul><li>也是因为这个东西做鬼才衍生出来了代练，演员</li></ul></li><li><p>氪金  </p><ul><li><p>“腾讯游戏，<del>用心创造快乐</del> 没钱玩尼B” 纵观国内的游戏市场，有多少款游戏是少氪金或者0氪金的呢。有更强大的武器出来了，你需要充钱才能购买，有好康的服饰出来了，你得充钱才能拥有，有箱子可以开了，你需要钱来购买箱子。(???)<br>有的人可能会问：游戏商不赚钱的嘛？搁这儿做公益呢？  </p></li><li><p>那你们玩着同一个游戏，你们技术水平相当，就因为对面那人儿，氪了金，他的武器伤害要比你高，你死了。这能怪谁？  </p></li><li>还有种怪象，你们玩着吃鸡类的游戏，人人都想着在地图里巴不得找个地一直猥琐到决赛圈吃鸡，然后你披着一身亮眼的衣服趴在草丛里，真当对手眼瞎？还是你自己脑残，掩耳盗铃？  </li><li>那氪金是否破坏了一个游戏的公平性？不，只要你我都不氪金，人人都是公平的。那是什么破坏了我的体验？<br><strong>人的攀比、虚荣</strong>  </li></ul></li><li>环境<ul><li>有多少人是因为真正喜欢一款游戏而玩下去的，据我所知，有不少人玩游戏就是为了去带妹、撩骚，或者去享受被带的快感。成年人嘛，多多少少想追求一点刺激，而且我一直搞不明白的就是游戏大厅的存在究竟是为了让玩家更好的交流，还是为了给卖黄片、约炮、诈骗的人一个更好的平台，游戏玩腻了，来轻松♂ 一下  </li><li>祖安队友也是不可避免的存在，多少次我只想好好地打个游戏放松一下，队友祖安掘墓人，对面网易阴阳师(我玩你🐎)</li></ul></li></ol><hr><h1 id="我是如何降低游玩频率的"><a href="#我是如何降低游玩频率的" class="headerlink" title="我是如何降低游玩频率的"></a>我是如何降低游玩频率的</h1><h2 id="不被潮流牵引"><a href="#不被潮流牵引" class="headerlink" title="不被潮流牵引"></a>不被潮流牵引</h2><ol><li>我比较喜欢游戏内每一个角色故事丰满(角色刻画到位)，且背景故事足够科幻，能够吸引我，守望先锋作为现在我时不时就要玩的游戏可谓是再最和我胃口的，没有太多花里胡哨的东西，像我这样又菜又想一直陪着这个游戏的大有人在。市面上的主流游戏，要嘛我不喜欢(了)，要嘛就是没有玩的动力，自然很多游戏对我根本没有太大的吸引力<h2 id="给自己找事儿干"><a href="#给自己找事儿干" class="headerlink" title="给自己找事儿干"></a>给自己找事儿干</h2></li><li><p>思考自己玩游戏的时间，原来我是喜欢一大早就起来，然后打开电脑，刷完没有看完的视频，然后就开始游戏，经常一打就是打一天，饭吃完就继续，或者有时候干脆不吃。久了之后，我意识到游戏好像占据了我太多的时间，但是是确实找不到事儿干才玩的游戏，然后我开始在学校大清早就跑去图书馆，一有空就坐着自习，不得不说解决一个问题获得的满足要比赢一把游戏更放松。  </p></li><li><p>在家的时候就去找一些自己能去实践的小东西，自己去动手解决问题，然后最终实现它。你会发现时间过得无比的快，像半个月前我有的时候周末两天直接忙完，有时想玩会游戏都觉得太晚了，压缩自己能玩游戏的时间，把它留给更有意义的事</p></li></ol><hr><h1 id="BB专区"><a href="#BB专区" class="headerlink" title="BB专区"></a>BB专区</h1><ul><li>玩游戏可以，但是别把玩游戏厉害当作骄傲的资本  </li><li>游戏本身也没有高低贵贱之分，一款游戏只要有人玩就说明这款游戏在某些地方吸引着玩家，也不必去做过多嘲讽  </li><li>该玩玩，该做事做事，不要边做事的时候边玩游戏  </li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>游戏的的确确成为了大部分人生活中的一部分，有空了、闲的没事儿做了都会玩一玩游戏，这篇文章的主旨也不是在阐述玩游戏不好，更多的是从我个人出发，揭示很多时候玩游戏并不是为了真正的乐趣，希望认真看完这篇文章的你有一些想法<br>现在的我早已不把游戏当作不可分割的一部分了，有人找我玩游戏，我想玩就玩，没人找我我就时不时放松一下。感觉每天的时间我可以干更多的事情。作为跳出局的局外人，看待这一切都觉得原来那个沉迷在游戏里的自己是那么幼稚。望每个沉迷在游戏里的有志青年都能早日摆脱游戏的束缚，找到自己的方向</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日随记</title>
      <link href="article/thesedays/"/>
      <url>article/thesedays/</url>
      
        <content type="html"><![CDATA[<p>放假放了这么久了，还没怎么写过博客，正好最近有一些想写的东西，就一起整合起来写到博客里<br>分为以下几个板块:   </p><ul><li>学习方面  </li><li>生活方面  </li><li>感情方面  </li><li><p>其他</p><a id="more"></a><h1 id="3-1-4-4�-…"><a href="#3-1-4-4�-…" class="headerlink" title="3.1~4.4�?…"></a>3.1~4.4�?…</h1><h2 id="1-学习方面"><a href="#1-学习方面" class="headerlink" title="1.学习方面"></a>1.学习方面</h2></li><li><p><u>情况�?</u></p><p>学校在上个月就安排了在线网络学习<br>开了的课程有：<strong>高数、线代、英语、思修、C语言</strong></p></li><li><p><u>自身�?</u></p><p>没得说，放假后是啥样就还是啥样，没有学校里面那种很好的氛围，在家里很懒散，学东西也比较慢，自控力还是不行，羡慕那种哪都能学习�?</p></li><li><p><u>BB:</u></p><p>说实话我们这个专业我感觉挺水的，C语言是上周才开始讲课的，按照学校的安排应该是第一周就会有这门课，感觉网工被当作了<br>计算机学院的孤儿……</p><p>在课程安排里面的大学物理也没开设网课，老师只是在群里面放上了学习资料叫我们自己有兴趣自�?.</p><p>我确实表示怀疑，有理由、有时间开设的课程为什么不能在第一时间上课，据我所知其他专业上网课第一�?.<br>就有大物和C语言</p><p>而且学习平台上放的网课那能叫“网课”？全部是照着课件给你念一遍，我是眼睛有问题还是脑子有问题非得去看那视频？</p></li></ul><hr><h2 id="2-生活方面"><a href="#2-生活方面" class="headerlink" title="2.生活方面"></a>2.生活方面</h2><ul><li><p>球球了，快开学吧，在家的大学生毫无人权，天天看老师直播之余还得抽空去煮个饭（抹泪），我真想哪次我去煮饭去了被点名到回答问题</p></li><li><p>身体一天不如一天（雾）单纯地没有怎么运动，天天宅在家，路都快走不动了</p></li><li><p>没钱！！！在家蹭吃蹭喝，莫得零花钱，我的支付包里面还�?70块钱…想买点东西都只能看着，我太难�?</p></li></ul><hr><h2 id="3-情感方面"><a href="#3-情感方面" class="headerlink" title="3. 情感方面"></a>3. 情感方面</h2><ul><li><p>还算比较顺利，告别了这么久，还一次没有吵过架，她前段时间给我说的分开后没有安全感，一天不找她聊天我也一直在改，确实前段时间有些做得不好，也一直害怕回的消息不够（那啥�?.</p></li><li><p>我觉得目前为止我做得还算是比较满�?(自我感觉良好)，但有些时候确实过分地小心翼翼了，她告诉我自然一点，当然这个我也会慢慢地去适应.</p></li><li><p>在一起了这么多天，感触确实挺大的，有时候不知道她在干嘛，想找她聊天，她却又不空或者没来的及回，有时还是比较失落，这种虚无的感觉让我很是难�?.</p></li><li><p>我觉得面对面一起说话才是最好的交流方式，你知道对方的表情，语气，你知道怎么更好地去回答，但当这一切按照文字的方式传递给对方，就流失了很大一部分的信息，一句话可能产生歧义，解释的时候又因为全是文字的原因不能快速地去表�?</p></li><li><p>毫无保留地说我确实一天比一天想她，是因为我想去见她，而不是一直停留在每天的打字上</p></li></ul><hr><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><ul><li><p>今年年前回家时，告诉我搬家了，新的家还是有点不习惯，住在底楼，有些潮湿和�? ，面积稍微小了一点，不过无所谓，有个能睡觉的地方就可以了。听说爸妈准备再搬，去另外一个小区，现在还在准备装修，等到下次放假的时候回来又是另外一间房子了</p></li><li><p>底楼的好处就是可以打开门直接出去，我们家旁边有很多的野猫，我发现他们后就买了猫粮天天喂它们，每天都有小家伙来陪我还是挺好的，不过最近的猫越来越少了…难受</p></li><li><p>耍的好的基友又被关进监狱�?(他是复读�?)，游戏最近也很少打了，大都是学累了后自己一个人玩玩OW</p></li><li><p>为什么还没开学的消息啊！我想回学校学习！我想实验室了�?</p><p><strong>写到这觉得没啥写的了，想起来4�?7日是我家小可爱的生日~ 再来�?</strong>  </p><ul><li><p>她生日前我觉得我挺憨的，去问送￥%#(代指某种礼物)好不�?…</p><p>我感觉我是合金憨�?</p><p>礼物已经重新帮她选了，现在还在来我家的路�?(预计4�?6号到…)，顺丰给点面子快一点行不行�?5号到吧，然后我还去买了包装纸，准备包装一下再自己发给�?</p><p>刚看了下物流，包装纸预计5号到，球球了，一起来�?</p><p>然后明早再去买其他的东西，希望她拿到的时候不要太�?</p></li></ul></li></ul><hr><p>  <strong>以上就是最近我的记录了，感觉没干啥，但是时间过得飞快，今天(4.4)大部分游戏停服，这难道就是我的转角吗（希望如此），但我已经不求这学期能有很高的绩点了，别挂科就行</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开张啦~</title>
      <link href="article/Opened/"/>
      <url>article/Opened/</url>
      
        <content type="html"><![CDATA[<p><strong>终于在今天完成了所有这个网站的前期工作，从明天开始就是正式运行啦</strong></p><p><strong>以后请多多指教</strong></p><blockquote><p>无限进步</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="article/hello-world/"/>
      <url>article/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World！<br>这是我建立的第一个静态博客鸭，以前听说过hexo，但迫于自身太菜所以就没有去搭建，现在放假闲下来了就搭建好了这个简单的博客<br>想查看更多信息可以阅读完这篇文章，也可以去 <a href="https://codgi.xin/about">关于Codgi的小屋</a> 查看<br><a id="more"></a><br><strong>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check #%&amp;^%#%&amp;$%&amp;^$ <del>好的我知道了</del></strong></p><h2 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h2><h3 id="1-原来从来没有用过markdown-（我就是个菜鸡√）"><a href="#1-原来从来没有用过markdown-（我就是个菜鸡√）" class="headerlink" title="1.原来从来没有用过markdown （我就是个菜鸡√）"></a>1.原来从来没有用过markdown （我就是个菜鸡√）</h3><p>了解markdown，以及熟悉他的用法可能还需要一段时间，也有许多工具可以将Word格式的文章转换为markdown，但我觉得这样好像失去了直接这样书写的乐趣，反正需要用到的语法也不是太多，也有帮助文档可以看，索性以后都用markdow来写我的文章咯~ <del>段落的换行…两个以上空格加回车</del></p><p>oh~逐渐熟练，以后文章里面应该会包含代码以及公式，只有先预习一下了</p><p>More info：<a href="https://blog.csdn.net/witnessai1/article/details/52551362">语法手册</a></p><h3 id="2-hexo我也是第一次接触它"><a href="#2-hexo我也是第一次接触它" class="headerlink" title="2.hexo我也是第一次接触它"></a>2.hexo我也是第一次接触它</h3><p>这里是hexo的官方网站：<a href="https://hexo.io/">Hexo</a></p><p>简单来说，Hexo是一个快速、简洁、高效的博客框架，使用Markdown（或者其他渲染引擎）解析文章，并利用主题生成静态网页</p><p>这里是Hexo的官方中文文档：<a href="https://hexo.io/zh-cn/docs/index.html">文档|Hexo</a></p><h3 id="这是我的第二个网站"><a href="#这是我的第二个网站" class="headerlink" title="这是我的第二个网站"></a>这是我的第二个网站</h3><p>第一个使用的是Wordpress，里面的主题始终让我不满意，有很多时候需要去改主题的源代码，想加一个插件又怕跟主题不能兼容<br>百般无奈，新开一个，这里就记录学习、思考，那边记录生活，琐事。<del>免得把狗骗进来杀</del>  </p><h3 id="More："><a href="#More：" class="headerlink" title="More："></a>More：</h3><p>  博客所使用的主题：<a href="https://github.com/Molunerfinn/hexo-theme-melody">Melody</a><br>  主题作者的博客：<a href="https://molunerfinn.com/">MARKSZ</a><br>  同时感谢<a href="https://sheey.moe">Sheey</a>的帮助和解答</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
