<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java复习(更新ing)</title>
      <link href="/article/java-priview/"/>
      <url>/article/java-priview/</url>
      
        <content type="html"><![CDATA[<p>菜鸡的Java复习</p><a id="more"></a><h2 id="java基础"><a class="markdownIt-Anchor" href="#java基础"></a> <strong>Java基础</strong></h2><ul><li><p><code>Java SE(Standard Edition)</code> 标准版本。<br /><code>Java EE (Enterprise Edition)</code> 企业版本<br /><code>Java ME(Micro Edition)</code> 微型版本。</p></li><li><p>常用概念</p><ul><li>JDK：Java开发工具包</li><li>JVM：Java虚拟机</li><li>JRE：Java运行环境</li></ul></li><li><p>JDK目录构成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk1.8.0</span><br><span class="line">      |-bin</span><br><span class="line">         |- java.exe</span><br><span class="line">         |- javac.exe</span><br><span class="line">         |- javap.exe</span><br><span class="line">         |- javah.exe</span><br><span class="line">         |- javadoc.exe</span><br><span class="line">      |-lib</span><br><span class="line">         |- tools.jar</span><br><span class="line">         |- dt.jar</span><br><span class="line">      |-jre</span><br><span class="line">         |- bin</span><br><span class="line">             |- java.exe</span><br><span class="line">             |- java.dll</span><br><span class="line">             |- awt.dll</span><br><span class="line">             |- server</span><br><span class="line">                  |- jvm.dll</span><br><span class="line">         |- lib</span><br><span class="line">             |-rt.jar</span><br><span class="line">             |-ext</span><br><span class="line">             |-security</span><br></pre></td></tr></table></figure></li><li><p>编译、执行命令</p><ul><li><code>javac xxx.java</code></li><li><code>java 类名(不加任何后缀)</code></li></ul></li></ul><hr /><h2 id="java语言基础"><a class="markdownIt-Anchor" href="#java语言基础"></a> <strong>Java语言基础</strong></h2><h3 id="标识符定义规则"><a class="markdownIt-Anchor" href="#标识符定义规则"></a> 标识符定义规则</h3><ol><li><p>标识符由26个英文字符大小写（a<sub>zA</sub>Z）、数字(0~9)、下划线(_)和美元符号($)组成。</p></li><li><p>不能以数字开头，不能是关键字</p></li><li><p>严格区分大小写</p></li><li><p>标识符的可以为任意长度</p></li><li><p>包名 多个单词组成时所有字母小写</p></li><li><p>类名和接口 多个单词组成时所有单词的首字母大写</p></li><li><p>变量名和函数名 多个单词组成时第一个单词首字母小写，其他单词首字母大写</p></li><li><p>常量名 多个单词组成时，字母全部大写，多个单词之间使用_分隔</p></li><li><p>虽然Java取消了goto,const这些关键字，但不能用来作为标识符使用</p></li></ol><h3 id="整性"><a class="markdownIt-Anchor" href="#整性"></a> 整性</h3><ul><li><p><code>byte:</code> 一个字节、8位，取值范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">-127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>,默认值是 <code>0</code></p></li><li><p><code>short:</code> 两个字节、16位，取值范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>32768</mn></mrow><annotation encoding="application/x-tex">-32768</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32767</mn></mrow><annotation encoding="application/x-tex">32767</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">7</span></span></span></span>,默认值是 <code>0</code></p></li><li><p><code>int:</code> 四个字节、32位，取值范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1,默认值是 <code>0</code></p></li><li><p><code>long:</code> 八个字节、64位，取值范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>63</mn></msup></mrow><annotation encoding="application/x-tex">-2^{63}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup></mrow><annotation encoding="application/x-tex">2^{63}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>-1，默认值是 <code>0L</code><br /><strong>如果整性后没有字母默认是<code>int</code></strong></p></li></ul><h3 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h3><ul><li><p><code>float:</code> 单精度型，四个字节，32位，默认值是 <code>0.0f</code></p></li><li><p><code>double:</code> 双精度型，八个字节，64位，默认值是 <code>0.0d</code><br /><strong>如果浮点数后没有字母，默认是<code>double</code></strong></p></li></ul><h3 id="字符型"><a class="markdownIt-Anchor" href="#字符型"></a> 字符型</h3><ul><li><code>char:</code> 两个字节、16位，取值范围：<strong>0~65535</strong></li></ul><h3 id="基本数据类型相互转换"><a class="markdownIt-Anchor" href="#基本数据类型相互转换"></a> 基本数据类型相互转换</h3><ul><li><p><code>byte short char</code> 进行运算时转换成 <code>int</code></p></li><li><p>其余情况转换成字节占用最高的</p></li></ul><h3 id="java结构化语句"><a class="markdownIt-Anchor" href="#java结构化语句"></a> <strong>Java结构化语句</strong></h3><h4 id="分支语句"><a class="markdownIt-Anchor" href="#分支语句"></a> 分支语句</h4><ul><li><p><code>switch(expression)</code>语句中，<code>expression</code>的数据类型只能是<code>byte short char int</code></p></li><li><p><code>switch</code> 结构中，每一个<code>case</code>后必须跟上<code>break</code>，否则会继续执行后面的<code>case</code>语句，直到遇到<code>break</code>或者<code>switch</code>结束</p></li></ul><h4 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h4><ul><li><p><code>for</code>类型循环多用于数值型循环</p></li><li><p><code>break</code>语句可以用在循环体或者<code>switch</code>语句中，表示跳出当前循环体或者<code>switch</code></p></li></ul><hr /><h2 id="面向对象基础"><a class="markdownIt-Anchor" href="#面向对象基础"></a> 面向对象基础</h2><ul><li><p>Java是一门面向对象编程语言</p><h3 id="面向对象编程的三大特性"><a class="markdownIt-Anchor" href="#面向对象编程的三大特性"></a> 面向对象编程的三大特性</h3><ul><li>封装、继承、多态</li></ul><h3 id="对象和类的关系"><a class="markdownIt-Anchor" href="#对象和类的关系"></a> 对象和类的关系</h3><ul><li>类是对象的抽象，对象是类的实例化</li></ul><h3 id="类的定义属性-构造方法-方法"><a class="markdownIt-Anchor" href="#类的定义属性-构造方法-方法"></a> 类的定义（属性、构造方法、方法）</h3><p><strong>类的定义需要使用<code>class</code>关键字，可能还会指定继承自某一个类，或者需要实现某些接口</strong></p><ul><li><p><strong>一个类可以包含如下变量</strong></p><ul><li><p><strong>类变量</strong><br />类变量也声明在类中，方法体之外，但必须声明为 static 类型</p></li><li><p><strong>成员变量(属性)</strong></p><ul><li><p>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。</p></li><li><p>属性不仅可以使简单类型变量，也可以是一个对象</p></li><li><p>成员变量可以被类中方法、构造方法和特定类的语句块访问。</p></li></ul></li><li><p><strong>局部变量</strong><br />在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p><p><strong>所有的变量在使用前都必须进行初始化,方法中的变量必须显示初始化。</strong></p></li></ul></li><li><p><strong>构造方法</strong><br />每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><ul><li>构造方法名与类名相同</li><li><strong>构造方法没有返回值</strong></li><li>在创建新对象时，系统自动的调用该类的构造方法</li><li>一个类可以有多个构造方法</li><li>如果显示定义了任意一个构造方法，那么默认的无参构造方法不会生成</li></ul></li><li><p><strong>方法</strong><br /><strong>方法是语句的集合，它们在一起执行一个功能。</strong><br />方法包括<code>修饰符、返回值类型、方法名、参数类型、方法体</code></p></li></ul><h3 id="实例化对象"><a class="markdownIt-Anchor" href="#实例化对象"></a> 实例化对象</h3><p><code>new</code>创建一个对象<code>S</code>时进行的步骤：</p><ol><li>加载<code>.class</code>文件</li><li>在栈内存为<code>S</code>申请空间</li><li>在堆内存为对象申请空间</li><li>对成员变量进行默认初始化</li><li>对成员变量进行显示初始化</li><li>执行构造方法</li></ol><h3 id="this-和-super"><a class="markdownIt-Anchor" href="#this-和-super"></a> <code>this</code> 和 <code>super</code></h3><ul><li><p><code>this</code>是自身的一个对象，代表对象本身，可以理解为指向自己的一个指针</p></li><li><p><code>super</code>可以理解为是指向自己超（父）类对象的一个指针，指的是离自己最近的一个父类</p></li></ul><h3 id="static"><a class="markdownIt-Anchor" href="#static"></a> <code>static</code></h3><ul><li>创建一块静态内存区，在静态内存区为静态属性分配空间</li><li>当JVM加载类时，就会执行</li></ul><h4 id="static的使用方法"><a class="markdownIt-Anchor" href="#static的使用方法"></a> <code>static</code>的使用方法</h4><ul><li>如果想在不创建对象的情况下调用某个方法，则可以通过将这个方法设置为static来实现。</li><li>在静态方法中不可以使用this关键字</li><li>静态方法可以直接通过类名调用，任何的实例也都可以调用</li><li>不能直接访问所属类的实例变量和实例方法</li></ul><h3 id="访问控制符"><a class="markdownIt-Anchor" href="#访问控制符"></a> 访问控制符</h3><p><img src="https://s3.ax1x.com/2020/12/15/rMi7kT.png" alt="访问控制" /></p><h3 id="继承的意义和使用方法"><a class="markdownIt-Anchor" href="#继承的意义和使用方法"></a> 继承的意义和使用方法</h3><p><strong>Java中类之间只允许单一继承</strong></p><h4 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h4><ol><li>在 Java 中通过 <code>extends</code> 关键字可以申明一个类是从另外一个类继承而来的，<code>extends</code> 只能继承一个类，一般形式如</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>或者使用<code>implements</code>关键字，让当前类继承某个或多个接口</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>通过内部类间接实现多继承</strong><br />如果父类为抽象类或者具体类，那么就仅能通过内部类来实现多重继承，见下</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">str</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">can</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Father_1</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">str</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.str() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mother_1</span> <span class="keyword">extends</span>  <span class="title">Mother</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">can</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.can() - <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Father_1().str();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getcan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Mother_1().can();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Son son = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println( son.get());</span><br><span class="line">    System.out.println( son.getcan());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承类型"><a class="markdownIt-Anchor" href="#继承类型"></a> 继承类型</h4><img src="https://s3.ax1x.com/2020/12/15/rKOFpV.png" width="80%" height="80%"><p><em>注：上图中所描述的不支持多继承指的的类之间</em></p><h4 id="继承的特性"><a class="markdownIt-Anchor" href="#继承的特性"></a> 继承的特性</h4><ul><li><p>子类拥有父类非 <code>private</code> 的属性、方法</p></li><li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</p></li><li><p>子类可以用自己的方式实现父类的方法</p></li><li><p>提高了类之间的耦合性(耦合度高就会造成代码之间的联系越紧密，代码独立性越差)</p></li><li><p>当一个类没有继承的两个关键字<code>extends</code>或<code>implements</code>时，则默认继承<code>object</code></p></li></ul><h3 id="多态性"><a class="markdownIt-Anchor" href="#多态性"></a> 多态性</h3><p>多态：同一个行为具有多个不同表现形式或形态的能力</p><ul><li>多态存在的三个必要条件<ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<code>Parent p = new Child();</code></li></ul></li></ul><h3 id="final和abstract"><a class="markdownIt-Anchor" href="#final和abstract"></a> <code>final</code>和<code>abstract</code></h3><h4 id="final"><a class="markdownIt-Anchor" href="#final"></a> <code>final</code></h4><p><code>final</code> 修饰类则表示这个类是无法被继承的类, 也就是在类族树中最底层的类,  如果你不想该类被派生出子类, 那么可以用final 来修饰这个类</p><ul><li><code>private</code> 方法会被认为是<code>final</code>方法</li><li><code>final</code> 变量必须赋值</li></ul><h4 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> <code>abstract</code></h4><p>abstract 的中文意思是抽象的, 就是这个东西不存在, 也就是不能被直接实例化</p><ul><li><code>abstract</code> 可以修饰类，类的方法</li></ul><h5 id="abstract-修饰类"><a class="markdownIt-Anchor" href="#abstract-修饰类"></a> <code>abstract</code> 修饰类</h5><ul><li>抽象类不能直接实例化</li><li>类中如果有一个或多个abstract方法，则该类必须声明为abstract</li><li>抽象类中的方法不一定都是abstract方法，它还可以包含一个或者多个具体的方法</li><li>抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用</li><li>如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类</li></ul><h5 id="abstract-修饰类方法"><a class="markdownIt-Anchor" href="#abstract-修饰类方法"></a> <code>abstract</code> 修饰类方法</h5><ul><li>抽象方法不能包含函数体, 而且要用分号结尾</li><li>不能用private 修饰抽象方法</li><li>不能用static 修饰抽象方法</li></ul><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>是抽象方法的集合，接口通常以<code>interface</code>来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法</p><h4 id="接口的声明"><a class="markdownIt-Anchor" href="#接口的声明"></a> 接口的声明</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的实现"><a class="markdownIt-Anchor" href="#接口的实现"></a> 接口的实现</h4><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure><p><strong>比如：</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;<span class="comment">//接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;<span class="comment">//实现</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mammal eats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mammal travels"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">    m.eat();</span><br><span class="line">    m.travel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>重写接口中声明的方法时：</p><ul><li>重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法</li></ul></li><li><p>实现接口时</p><ul><li>一个类可以同时实现多个接口</li></ul></li></ul><h4 id="接口的继承"><a class="markdownIt-Anchor" href="#接口的继承"></a> 接口的继承</h4><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingGoalScored</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfPeriod</span><span class="params">(<span class="keyword">int</span> period)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overtimePeriod</span><span class="params">(<span class="keyword">int</span> ot)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的多继承"><a class="markdownIt-Anchor" href="#接口的多继承"></a> 接口的多继承</h4><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span>, <span class="title">Event</span></span></span><br></pre></td></tr></table></figure><h3 id="java-包package"><a class="markdownIt-Anchor" href="#java-包package"></a> Java 包(package)</h3><p>Java 使用包<code>package</code>这种机制是为了防止命名冲突，访问控制，提供搜索和定位类<code>class</code>、接口、枚举<code>enumerations</code>和注释<code>annotation</code>等。</p><h4 id="创建包"><a class="markdownIt-Anchor" href="#创建包"></a> 创建包</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[．pkg2[．pkg3…]];</span><br></pre></td></tr></table></figure><h4 id="引入包"><a class="markdownIt-Anchor" href="#引入包"></a> 引入包</h4><p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用 <code>import</code>可完成此功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2…].(classname|*);</span><br></pre></td></tr></table></figure></li></ul><hr /><h2 id="java常用类"><a class="markdownIt-Anchor" href="#java常用类"></a> Java常用类</h2><h3 id="sting类"><a class="markdownIt-Anchor" href="#sting类"></a> Sting类</h3><h4 id="创建string字符串"><a class="markdownIt-Anchor" href="#创建string字符串"></a> 创建String字符串</h4><ol><li>最简单创建字符串的方式</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Codgi"</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用构造函数创建字符串</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> string(<span class="string">"Codgi"</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：如果是采用直接创建的方法，则存储空间是分配在公共池中(地址相同)，若采用<code>new</code>分配则分配在堆上</strong></p><h4 id="string常用的方法"><a class="markdownIt-Anchor" href="#string常用的方法"></a> String常用的方法</h4><ul><li><p><code>int length()</code> 获取字符串长度<br /><strong>注意：对于字符串而言，获取长度是方法，而对于数组而言，获取长度是通过属性</strong></p></li><li><p><code>String concat(String str)</code> 连接两个字符串</p></li><li><p><code>char charAt(int index)</code> 返回指定索引处的字符</p></li><li><p><code>int compareTo(String str)</code> 按字典顺序比较两个字符串</p><ul><li>如果此字符串等于参数字符串，则返回值 0</li><li>如果此字符串小于字符串参数，则返回一个小于 0 的值</li><li>如果此字符串大于字符串参数，则返回一个大于 0 的值</li></ul></li><li><p><code>int indexOf(String str)</code> 返回指定子字符串在此字符串中第一次出现处的索引。</p></li><li><p><code>String replace(char oldChar, char newChar)</code> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</p></li><li><p><code>String replaceAll(String regex, String replacement)</code> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串</p></li><li><p><code>String[] split(String regex)</code> 根据给定正则表达式的匹配拆分此字符串。</p></li><li><p><code>char[] toCharArray()</code> 将此字符串转换为一个新的字符数组。</p></li><li><p><code>isEmpty()</code> 判断字符串是否为空。</p></li></ul><h3 id="stringbuffer-类"><a class="markdownIt-Anchor" href="#stringbuffer-类"></a> StringBuffer 类</h3><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer</p><h4 id="创建stringbuffer字符串与string大体相同"><a class="markdownIt-Anchor" href="#创建stringbuffer字符串与string大体相同"></a> 创建StringBuffer字符串与String大体相同</h4><pre><code>略</code></pre><h4 id="stringbuffer方法"><a class="markdownIt-Anchor" href="#stringbuffer方法"></a> StringBuffer方法</h4><ul><li><code>StringBuffer append(String s)</code> 将指定的字符串追加到此字符序列</li><li><code>StringBuffer reverse()</code>  将此字符序列用其反转形式取代</li><li><code>delete(int start, int end)</code> 移除此序列的子字符串中的字符</li><li><code>insert(int offset, int i)</code> 将 int 参数的字符串表示形式插入此序列中的<code>i</code>位</li><li><code>replace(int start, int end, String str)</code> 使用给定 String 中的字符替换此序列的子字符串中的字符。</li><li>其余的方法与String相同</li></ul><h3 id="calendar类"><a class="markdownIt-Anchor" href="#calendar类"></a> Calendar类</h3><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，使用<code>getInstance</code>方法创建</p><h4 id="创建一个代表系统当前日期的calendar对象"><a class="markdownIt-Anchor" href="#创建一个代表系统当前日期的calendar对象"></a> 创建一个代表系统当前日期的Calendar对象</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();<span class="comment">//默认是当前日期</span></span><br></pre></td></tr></table></figure><h4 id="calendar类对象字段类型"><a class="markdownIt-Anchor" href="#calendar类对象字段类型"></a> Calendar类对象字段类型</h4><ul><li><p>Calendar.YEAR年份</p></li><li><p>Calendar.MONTH月份</p></li><li><p>Calendar.DATE日期</p></li><li><p>Calendar.DAY_OF_MONTH日期，和上面的字段意义完全相同</p></li><li><p>Calendar.HOUR12小时制的小时</p></li><li><p>Calendar.HOUR_OF_DAY24小时制的小时</p></li><li><p>Calendar.MINUTE分钟</p></li><li><p>Calendar.SECOND秒</p></li><li><p>Calendar.DAY_OF_WEEK星期几</p></li></ul><h4 id="calendar类对象信息的获得"><a class="markdownIt-Anchor" href="#calendar类对象信息的获得"></a> Calendar类对象信息的获得</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);<span class="comment">// 获得年份</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">// 获得月份</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> date = c1.get(Calendar.DATE);<span class="comment">// 获得日期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hour = c1.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获得小时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minute = c1.get(Calendar.MINUTE);<span class="comment">// 获得分钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> second = c1.get(Calendar.SECOND);<span class="comment">// 获得秒</span></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h4><ul><li><p><code>add</code> 把cal对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算<br /><code>c1.add(Calendar.DATE, 10);</code>’</p></li><li><p>把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算<br /><code>c1.add(Calendar.DATE, -10);</code></p></li></ul><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><hr /><h2 id="java图形界面"><a class="markdownIt-Anchor" href="#java图形界面"></a> Java图形界面</h2><h3 id="java-gui介绍"><a class="markdownIt-Anchor" href="#java-gui介绍"></a> Java GUI介绍</h3><h4 id="awtabstract-window-toolkit"><a class="markdownIt-Anchor" href="#awtabstract-window-toolkit"></a> AWT(Abstract Window Toolkit)：</h4><p>抽象窗口工具包，早期编写图形界面应用程序的包</p><h4 id="swing"><a class="markdownIt-Anchor" href="#swing"></a> Swing</h4><p>Swing：为解决 AWT 存在的问题而新开发的图形界面包。Swing是对AWT的改良和扩展<br /><strong>AWT和Swing都是java中的包，AWT包的名称是java.awt，Swing包的名称是javax.swing</strong></p><h3 id="常用的组件swing中"><a class="markdownIt-Anchor" href="#常用的组件swing中"></a> 常用的组件(swing中)</h3><ul><li><strong><code>JLabel</code> 显示一行文字，可带图标</strong></li><li><strong><code>JTextFiel</code> 用户让用户输入一行文字的组件</strong></li><li><strong><code>JButton</code> 用于点击执行命令</strong></li><li><strong><code>JCheckBox</code> 复选框</strong></li><li><strong><code>JRadioButton</code>单选按钮</strong></li><li><strong><code>JComboBox</code>下拉列表框供选取</strong></li><li><strong><code>JList</code>一组列表项供选择</strong></li></ul><h3 id="顶层容器-jframe"><a class="markdownIt-Anchor" href="#顶层容器-jframe"></a> 顶层容器 —— JFrame</h3><ul><li>JFrame类是Window类的其中一个子类：通常用于定义一般意义的窗口</li><li>一个JFrame刚被创建后，其初始大小为height=width=0 ，而且是隐藏状态的，所以为了使Frame显示出来，必须在程序中显式地设置一下它的大小<br /><strong>注意：<code>setVisible(true);</code>：数据模型已经构造好，允许JVM可以根据数据模型执行paint方法开始画图并显示到屏幕上</strong></li></ul><h3 id="container类"><a class="markdownIt-Anchor" href="#container类"></a> Container类</h3><p>Container类是由Component类派生出来的一种特殊类，用来表示各种GUI组件的容器，其主要功能包括</p><ul><li>组件的管理：方法<code>add()</code>可以向其中添加一个组件，<code>remove()</code>删除其中的一个组件。</li><li>布局管理：每个Container类都和一个布局管理器相联，以确定其中组件的布局,通过<code>setLayout()</code>方法设置某种布局方式</li></ul><h3 id="中间容器-jpanel"><a class="markdownIt-Anchor" href="#中间容器-jpanel"></a> 中间容器 —— JPanel</h3><p><code>JPanel（面板）</code>可以更方便地组织自己的组件，得到更合理的布局。但面板不能作为窗口独立支配系统资源，必须放在相关容器中才可见,因此，需要将<code>JPanel</code>添加到其他容器中得以运行</p><h3 id="组件的通用方法"><a class="markdownIt-Anchor" href="#组件的通用方法"></a> 组件的通用方法</h3><ul><li><p><code>void setBackground(Color c)</code> : 设置组件的背景</p></li><li><p><code>Color getBackground()</code> :获取组件的背景色</p></li><li><p><code>void setForeground(Color c)</code> :设置组件的前景色</p></li><li><p><code>void setFont(Font f)</code> :设置组件的显示字体</p></li><li><p><code>Font getFont()</code> :获取组件的显示字体</p></li><li><p><code>void setEnabled(boolean b)</code> :是否让组件功能有效，在无效情况下组件变灰</p></li><li><p><code>void setVisible(boolean b)</code> :设置组件是否可见</p></li><li><p><code>void requestFocusInWindow()</code> : 让组件得到焦点</p></li><li><p><code>void add(PopupMenu popup)</code> ：给组件加入弹出菜单,但要和弹出菜单的show方法配合使用</p></li></ul><h3 id="常用组件及用法"><a class="markdownIt-Anchor" href="#常用组件及用法"></a> 常用组件及用法</h3><h4 id="jlabel-标签组件"><a class="markdownIt-Anchor" href="#jlabel-标签组件"></a> <code>JLabel</code> 标签组件</h4><ol><li><code>JLabel()</code> 创建空的标签</li><li><code>JLabel(String s)</code> 创建一个带初始字符串的标签</li><li><code>JLabel(String s，inti)</code> 创建一个带初始字符串及指定对齐方式的标签（i=0，2，4代表中左右）</li></ol><h4 id="jbutton-按钮"><a class="markdownIt-Anchor" href="#jbutton-按钮"></a> <code>JButton</code> 按钮</h4><p>当组件被点击时，产生AcitonEvent事件</p><ol><li><code>JButton (String Label)</code> 建立一个标示字符串为Label的按钮类对象。</li><li><code>JButton(Icon icon)</code> 创建一个带图标的按钮。</li></ol><h4 id="文本框"><a class="markdownIt-Anchor" href="#文本框"></a> 文本框</h4><h5 id="jtextfield-单行文本框"><a class="markdownIt-Anchor" href="#jtextfield-单行文本框"></a> <code>JTextField</code> 单行文本框</h5><p>单行文本框只能显示一行信息，会产生多种事件</p><ol><li><code>JTextField()</code> 创建空的单行文本框。</li><li><code>JTextField(int i)</code> 创建具有指定长度的文本框。</li><li><code>JTextField(String s)</code> 创建带有初始文本内容的文本框。</li><li><code>JTextField(String s,int i)</code> 创建带有初始文本内容并具有指定长度的文本框。</li></ol><h5 id="jtextarea-多行文本框"><a class="markdownIt-Anchor" href="#jtextarea-多行文本框"></a> <code>JTextArea</code> 多行文本框</h5><ul><li>多行文本框可以显示多行信息，并且需要滚动条支持。按回车键后并不产生事件</li><li>文本域需用<code>setLineWrap(boolean wrap)</code>设置为<code>true</code>，否则可能在规定的宽度不换行。</li><li><code>TextArea</code>不支持直接滚动。要创建滚动边框，需要让<code>JTextArea</code>作为<code>JScrollPane</code>的视口视图</li></ul><h5 id="文本框的常用方法"><a class="markdownIt-Anchor" href="#文本框的常用方法"></a> 文本框的常用方法:</h5><ul><li><code>getText()</code> 获取输入框中的数据</li><li><code>setText()</code> 往输入框写入数据</li><li><code>setEditable(boolean b)</code> 设置输入框是否可编辑。</li></ul><h4 id="jcheckbox-复选框"><a class="markdownIt-Anchor" href="#jcheckbox-复选框"></a> <code>JCheckBox</code> 复选框</h4><p>提供简单的选择框，同时旁边还可以显示说明信息。当复选框状态发生变化时，会产生<code>ItemEvent</code>事件</p><h5 id="常用构造方法"><a class="markdownIt-Anchor" href="#常用构造方法"></a> 常用构造方法：</h5><p><code>JCheckBox(String,boolean)</code> 创建一个指定显示标签和初始状态的复选框</p><h4 id="常用方法-2"><a class="markdownIt-Anchor" href="#常用方法-2"></a> 常用方法</h4><ul><li><code>boolean isSelected()</code> 获取复选按钮的选中状态，返回<code>true</code>代表按钮被选中</li><li><code>void setSelected(boolean value)</code> 设置复选按钮的状态，<code>value</code>为<code>true</code>表示选中。</li></ul><h4 id="选框组buttongroup单选框"><a class="markdownIt-Anchor" href="#选框组buttongroup单选框"></a> 选框组(ButtonGroup)——单选框</h4><p>当<code>JRadioButton</code>组件单独使用时，与复选框相同；如果利用<code>ButtonGroup</code>类分组，同一组的<code>JRadioButton</code>就构成单选框。选框组中的单选框之间是相互关联的，每次有且只有一个处于选中状态。</p><h4 id="jcombobox-下拉列表"><a class="markdownIt-Anchor" href="#jcombobox-下拉列表"></a> <code>JComboBox</code> 下拉列表</h4><p>下拉列表也称作组合框。它也可以通过<code>addItem (Object s)</code>方法增加选项，但每次只能选择一项。当选择发生时，会产生<code>ItemEvent</code>事件</p><h5 id="下拉列表常用方法"><a class="markdownIt-Anchor" href="#下拉列表常用方法"></a> 下拉列表常用方法</h5><ul><li><code>int getSelectedIndex()</code> 获取所选列表项对应的编号；</li><li><code>Object getSelectedItem()</code> 获取所选列表项对应的文字信息；</li><li><code>void #sdsetSelectedIndex(int Index)</code> 通过编号设置某项被选择；</li><li><code>void addItem (Object s)</code> 添加新列表项元素到列表中;</li><li><code>void removeItemAt (int Index)</code> 删除某个列表项元素;</li><li><code>void removeAllItems()</code> 删除所有列表项元素。</li></ul><h3 id="外观布局"><a class="markdownIt-Anchor" href="#外观布局"></a> 外观布局</h3><ul><li>在容器（JFrame和JPanel）中所有组件的布局都由布局管理器来控制，他们都有各自默认的布局管理器，也可以依据自身要求指定一个新的布局管理器</li><li>容器中布局管理器会自动设置各组件的大小和位置，用户无法手动改变这些属性，<code>即setLocation()</code> , <code>setSize()</code> , <code>setBounds()</code>等方法无效</li></ul><h4 id="流式布局flowlayout"><a class="markdownIt-Anchor" href="#流式布局flowlayout"></a> 流式布局(FlowLayout)</h4><p>FlowLayout以流式的方式，自左向右，自上而下的依次放置容器中的组件，一行放不下时再换行。他使用组件的最佳尺寸来显示组件。当容器被重新设置大小后，则布局也会随之发生改变：各组件的大小不变，但相对位置会改变。<br /><strong>FlowLayout类有三种构造方法：</strong></p><ul><li><p><code>public FlowLayout()</code><br />组件采用居中对齐方式，组件间的水平和竖直间距为默认值5个像素。</p></li><li><p><code>public FlowLayout(int align)</code><br />使用指定的对齐方式（值=0,1,2，代表左中右)，水平和竖直间距为缺省值5像素。</p></li><li><p><code>public FlowLayout(int align, int hGap, int vGap)</code><br />使用指定的对齐方式、水平间距、竖直间距。</p></li></ul><h4 id="网格布局gridlayout"><a class="markdownIt-Anchor" href="#网格布局gridlayout"></a> 网格布局(GridLayout)</h4><p>GridLayout布局方式可以使容器中的各组件呈网格状分布。各组件的排列方式仍为从上到下，从左到右。容器中各组件的高度和宽度相同，当容器的尺寸发生变化时，各组件的相对位置不变，但各自的尺寸会改变。<br /><strong>GridLayout类有三种构造方法：</strong></p><ul><li><p><code>publicGridLayout()</code><br />在一行中放置所有的组件，各组件间的水平间距为0像素。</p></li><li><p><code>publicGridLayout(int rows, int cols)</code><br />生成一个rows行，cols列的管理器，最多能放置rows*cols个组件。</p></li><li><p><code>publicGridLayout(int rows, int cols, int hGap, int vGap )</code><br />各组件间的水平和竖直间距为指定值</p></li></ul><h4 id="边框布局borderlayout"><a class="markdownIt-Anchor" href="#边框布局borderlayout"></a> 边框布局(BorderLayout)</h4><p>BorderLayout布局将整个容器的区域分为<code>East</code>, <code>South</code>, <code>West</code>, <code>North</code>和<code>Center</code>五个部分（如图所示），加入组件时需指明放置的位置，如果未指定位置，则缺省的位置是<code>Center</code>。当容器的尺寸发生变化时，各组件的相对位置不变，四周组件的厚度不会被改变，中间组件的大小需要改变<br /><strong>BorderLayout类有二种构造方法：</strong></p><ul><li><p><code>public BorderLayout()</code><br />各组件间的水平和竖直间距为缺省值0个像素。</p></li><li><p><code>public BorderLayout(int hGap, int vGap)</code><br />各组件间的水平和竖直间距为指定值。</p></li></ul><p>若容器使用了BorderLayout布局，用add()方法往容器中添加组件时必须指明添加的位置，若没有指明放置位置，则添加在默认的“Center”方位。</p><hr /><h2 id="java事件处理"><a class="markdownIt-Anchor" href="#java事件处理"></a> Java事件处理</h2><hr /><h2 id="java异常处理"><a class="markdownIt-Anchor" href="#java异常处理"></a> Java异常处理</h2><hr /><h2 id="java文件流"><a class="markdownIt-Anchor" href="#java文件流"></a> Java文件流</h2><hr /><h2 id="需要注意的"><a class="markdownIt-Anchor" href="#需要注意的"></a> 需要注意的</h2><ul><li><p><strong>java中没有按位左移运算符<code>&lt;&lt;&lt;</code></strong></p></li><li><p><strong>创建对象时,数据分配在堆空间,因为堆空间采用链式存储结构,所以能存大量的数据</strong></p></li><li><p><strong>抽象方法是没有方法体的方法</strong></p></li><li><p><strong>Java API文档不包括父类方法的列表</strong></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习-树</title>
      <link href="/article/ds-tree/"/>
      <url>/article/ds-tree/</url>
      
        <content type="html"><![CDATA[<p>临近考试，把PTA里面做过的题拿出来总结归纳复习一下，数据结构挺重要的，不能学成二吊子<br><a id="more"></a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li><p><strong>二叉树的第i层上最多含有结点数为$2^i−1$</strong></p></li><li><p><strong>在含有n个结点的树中,边数只能是n-1条</strong><br>  树中是不存在环的，对于有N个节点的树，必定是N-1条边</p></li><li><p><strong>叶结点个数等于度为2的结点个数加1</strong><br>  证明：设度数为0、1、2的节点个数分别为X,Y,Z,节点总数为N<br>  有<code>X+Y+Z=N，0*X+1*Y+2*Z=N-1</code>可解得<code>Z=X-1</code></p></li><li><p><strong>哈夫曼树的结点个数不能是偶数</strong><br>  哈夫曼树只有度为0和2的节点。<br>  假设度为0的节点为X，则度为2的节点为X-1；则节点个数为2X-1，始终为奇数</p></li></ul><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul><li><p>对 n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有 115 个结点，则 n 的值是<code>58</code></p></li><li><p>若将一棵树 T 转化为对应的二叉树 BT，则下列对 BT 的遍历中，其遍历序列与 T 的后根遍历序列相同的是：<code>中序遍历</code></p></li><li><p>一棵二叉树高度为h,所有结点的度或为0，或为2，则这棵二叉树最少<code>2h-1</code>结点</p></li><li><p>在二叉树结点的先序序列，中序序列和后序序列中，所有叶子结点的先后顺序<code>完全相同</code></p></li><li><p>在二叉树的顺序存储结构中（根的下标为1），下标为130的结点一定处于左子树中  </p><ul><li><em>解释：完全二叉树的顺序存储结构中，若根节点从1开始计数，则所有左子树的编号都为偶数，右子树为奇数</em></li></ul></li><li><p>一棵有n个结点的完全二叉树，按层次从上到下，同一层从左到右顺序存储在一维数组A[1..n]中，则二叉树中第i个结点（i从1开始用上述方法编号）的右孩子在数组A中的位置是<code>A[2i+1](2i+1&lt;=n)</code><br>  总结：完全二叉树中第i个节点的左孩子编号为<code>2i</code>，右孩子编号为<code>2i+1</code></p></li></ul><hr><h2 id="一些题型"><a href="#一些题型" class="headerlink" title="一些题型"></a>一些题型</h2><ul><li><p>在三种遍历结果中，取其中两种结果，为满足什么条件时，这两种遍历的结果相同</p><ul><li>解法：把三种遍历的结果写出来，然后看消掉其中哪一个后能够满足一样的结果</li></ul></li><li><p>二叉树性质相关类</p></li><li><p>根据题目算节点个数类</p></li><li><p>已知两个遍历序列，还原二叉树，写出最后一种遍历序列结果</p></li><li><p>哈夫曼树的带权路径长度</p></li><li><p>前缀编码</p></li></ul><hr><h2 id="与二叉树相关的"><a href="#与二叉树相关的" class="headerlink" title="与二叉树相关的"></a>与二叉树相关的</h2><ul><li><p><strong>哈夫曼树：</strong><br>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p></li><li><p><strong>前缀编码</strong><br>对字符集进行编码时，要求字符集中<code>任一字符的编码</code>都不是其它字符的<code>编码的前缀</code></p></li></ul><hr><h2 id="未解决"><a href="#未解决" class="headerlink" title="未解决"></a>未解决</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>已购赛博朋克2077</title>
      <link href="/article/newgame/"/>
      <url>/article/newgame/</url>
      
        <content type="html"><![CDATA[<p>对不起没忍住，入手价格149r，给🐻冲！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高数考试范围</title>
      <link href="/article/math/"/>
      <url>/article/math/</url>
      
        <content type="html"><![CDATA[<p>我们高数老师专门为我们开了一节课来讲期末考试的高数考试范围<br>wdm 我又可以了，记录一下，冲冲冲<br><a id="more"></a></p><h1 id="考试大纲"><a href="#考试大纲" class="headerlink" title="考试大纲"></a>考试大纲</h1><p>我们学校的考试卷子只有 选择、填空、解答题 三种题型，其中  </p><ol><li>选择题 每题4分、共5道、记20分</li><li>填空题 每题4分、共6道、记24分‘</li><li>解答题 每题8/10分、共7道，记56分<br>这次的复习课直接明确给出了选择题必考的三种题型、填空题必考的三种题型以及所有解答题的题型(总共92分XD)</li></ol><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p><strong>1. 求多元函数的定义域</strong><br>    &#160;非常简单，有手就行</p><p><strong>2. 判断直线与平面的位置关系</strong><br>    &#160;直接找方向向量和法向量的关系然后判断<br>    &#160;如果方向向量和法线垂直，特别注意直线和平面的<strong>重合情况</strong></p><p><strong>3. 求待定系数</strong><br>    &#160;其实就是 <strong>已知全微分，求未知数</strong>  </p><ul><li>解题方法：找出已知全微分中的P、Q，令$\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial x}$ 即可，解出其中的未知数</li></ul><p><strong>4. 交换二重积分次序</strong><br>    &#160;注意积分上下限的变化以及交换后式子的正负号</p><p><strong>5. 待定单选</strong>  </p><ul><li>下列说法正确的是(连续、可导、可微的关系)</li><li>级数在某个范围的收敛域<br><strong>个人觉得大概率是级数的题</strong></li></ul><hr><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><p><strong>1. 求二元函数(在某点的)全微分</strong>  </p><ul><li><p>求全微分：<br>${\mathrm{d}z}=\frac{\partial z}{\partial x}\mathrm{d}x+\frac{\partial z}{\partial y}\mathrm{d}y$</p></li><li><p>在某点的全微分：  </p><script type="math/tex; mode=display">{\mathrm{d}z(x_0,y_0)}=\frac{\partial z}{\partial x}|_{(x_0,y_0)}\mathrm{d}x + \frac{\partial z}{\partial y}|_{(x_0,y_0)}\mathrm{d}y</script><p><strong>即求出全微分后带入点</strong></p></li></ul><p><strong>2. 二元函数的极限</strong><br>&#160;即计算重极限，三种解题情况：  </p><ol><li>设 $xy=r$ (多项式均为 $x·y$ 情况时)</li><li>将式子拆分为 C·0 型(多用在式子中包含$\frac{C_1·(x^2)^a+C_2·(y^2)^b}{(x^2+y^2)^a}$ 时)</li><li>设$<br>\begin{cases}<br>x = x_0+r·\cos\theta \<br>y = y_0+r·\sin\theta<br>\end{cases}<br>$ （式子中x、y均为$x^2、y^2$时）</li></ol><p><strong>3. 第二类曲面积分</strong><br>&#160;重点考高斯公式(看内外侧，注意正负)，其余的看自己笔记本(XD太多了懒得写)</p><p><strong>4. 第一类曲线积分</strong><br>可以换成直线方程、参数方程，但也别忘了可以直接代入<br>注意按性质计算的情况：  </p><ol><li>$\int_{L} 1\, ds = L$ 的长度</li><li>关于$x=0、y=0$对称时的情况</li></ol><p><strong>5. 物理应用</strong><br><strong>明确指出：平面薄片的质量</strong></p><p><strong>6. 待定填空题</strong>  </p><ul><li>旋转后方程</li><li>幂级数展开</li><li>梯度</li></ul><hr><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><p><strong>1. 曲面在某点处的切平面、法线方程</strong><br>求出曲面在该点的切平面的法向量(该点处曲面的法向量)，然后用平面的点法式方程和直线的对称式方程分别表示出切平面方程和法线方程</p><p><strong>2. 抽象函数的一阶偏导</strong><br>&#160;主要是考察链式法则和用 $f’$ 表示偏导数</p><p><strong>3. 二重积分</strong><br>这个是真烦<br>简单的题直接土方法干，麻烦一点的涉及到:  </p><ul><li><strong>通过交换积分次序计算积分</strong><br>&#160;适用交换后计算更方便的情况</li><li><strong>通过极坐标变换计算积分</strong><br>&#160;积分区域被两条从原点发出的射线切割且圆润</li><li><strong>通过直线角坐标变换计算积分</strong><br>&#160;与通过极坐标变换计算积分的方法相反</li><li><strong>通过对称性计算积分</strong><br>&#160;关于$x、y、z$对称的三种情况</li><li><strong>通过轮换对称性计算积分</strong><br>&#160;积分区域关于直线$y=x$对称，且$f(x,y)+f(y,x)$的积分更好求</li><li><strong>通过积分区域形心计算积分</strong><br>&#160;被积函数=$?y+?x$，且形心好找或者关于$y=?$或$x=?$对称<br>计算方法：$\iint_{D} (ax+by)\, dx\,dy=(a\overline{x}+b\overline{y})·D的面积 ,(\overline{x},\overline{y})为D的形心坐标$</li></ul><p><strong>4. 三重积分</strong><br>&#160;<strong>局限在柱面坐标</strong><br>&#160;不好意思，这个我复习漏了呜呜呜呜呜呜呜，马上写完就去看</p><p><strong>5. 第二类曲线积分</strong><br>&#160;考察格林公式</p><p><strong>6. 全微分求原函数</strong><br>？我怎么没遇见过这种的  </p><ul><li><p>做题方法：<br>题目里面会给出$\frac{\partial u}{\partial x} 和 \frac{\partial u}{\partial y}$</p><p>$u=\int<em>{x_0}^{x}·(y 变成y_0后的 \frac{\partial u}{\partial x})dx + \int</em>{y_0}^{y} · \frac{\partial u}{\partial y}dy+C$</p><p>$x_0,y_0随便找，只要带入 \frac{\partial u}   {\partial x} 和 \frac{\partial u}{\partial y}$<br>中有意义即可(就是只要分母不为0)</p></li></ul><p><strong>7. 证明绝对收敛</strong><br>这个我智商不够，考试的时候随缘做吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>别搁这儿总结了，赶快去看吧，我还有好多没看完</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个困扰了我很久的问题</title>
      <link href="/article/lights/"/>
      <url>/article/lights/</url>
      
        <content type="html"><![CDATA[<p>亮度无法调节问题是出在这台笔记本电脑上的，以前都是重新装个驱动就好了，以为这次是中邪了，结果意外刷到了一篇文章，刚好解决了这个问题<br>wdnmd我的眼睛有救了<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我拿到这台电脑使用了很长一段时间都是没有问题的，晚上打游戏都是降低了亮度玩，结果有一次晚上发现无法调节亮度，去找了很多方法都没有成功，导致我的笔记本屏幕满亮度使用了起码有半年多的时间(我的眼睛呜呜呜)</p><h2 id="尝试过的解决办法"><a href="#尝试过的解决办法" class="headerlink" title="尝试过的解决办法"></a>尝试过的解决办法</h2><ul><li>重装系统  (注：后面又用不能调节了)</li><li>卸载显卡驱动程序并重装</li><li>更新驱动程序</li></ul><p><strong>除了重装系统后一段时间内能正常调节，其他方法均无效</strong></p><h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h2><p><strong>远程连接软件<a href="https://www.teamviewer.com/" target="_blank" rel="noopener">TeamViewer</a></strong>  </p><p>无意间刷CSDN刷到的一篇<a href="https://blog.csdn.net/weixin_40930415/article/details/104403071" target="_blank" rel="noopener">博文</a>发现的  </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>那篇博文里面提到了TeamViewer可能会导致亮度调节失效，于是我尝试了去设备管理器里将<code>监视器</code>下的<code>Generic Monitor (OrayDPMS)</code>卸载，然后检测硬件改动后他又回来了……<br>又查看了几个方法，去TeamViewer内将驱动卸载，结果提示我没有安装(exm?) 那对不住了，找到元凶了还不能让我干掉你，那我就把你卸了(/滑稽)  </p><p>然后尝试<code>Fn+F11/F12</code>  </p><p><strong>完美解决问题 Nice！ 我的眼睛有救了</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可能你会问我是怎么在晚上顶着高亮度坚持下来的<br>实在没办法我找到了一个软件：<a href="https://justgetflux.com/" target="_blank" rel="noopener">f.lux</a><br>他能设置一天内你屏幕的色温，我把晚上的色温调得很暖，减少了眼睛了压力(没有直接降低亮度来的爽，现在两个结合起来更舒服了)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>入手一台Raspberry Pi 4B</title>
      <link href="/article/RaspberryPi/"/>
      <url>/article/RaspberryPi/</url>
      
        <content type="html"><![CDATA[<p>近段时间想学学Linux方面的东西，但是Windows上的WSL我觉得虽然方便，但是用着没有单独Linux<br>那么畅快，所以入手Raspberry Pi来拿玩，但愿不要太快就吃灰了。  </p><p>这篇记录下Raspberry Pi的踩坑记录（md）<br><a id="more"></a></p><h1 id="Raspberry-Pi"><a href="#Raspberry-Pi" class="headerlink" title="Raspberry Pi"></a>Raspberry Pi</h1><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p><strong>1. HDMI无信号</strong><br>这个是个神奇的问题，我在把镜像文件（Ubuntu 18）烧录至SD卡后，插入Raspberry Pi后，连接上键盘和HDMI（输出至一台1920x1080的限制小电视）然后一直无信号。<br>我以为是系统出了问题，重新试了好多次都一直是无信号，最终在YouTube上看到了解决方案：  </p><ul><li><strong>Solve</strong>  <ol><li>将SD卡连至电脑，打开FAT32分区里面的<code>config.txt</code>文件  </li><li>更改/添加 以下配置： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#强制使用HDMI输出</span><br><span class="line">hdmi_force_hotplug&#x3D;1</span><br><span class="line"></span><br><span class="line">#HDMI信号增强</span><br><span class="line">config_hdmi_boost&#x3D;4</span><br><span class="line"></span><br><span class="line">#HDMI输出适配于计算机显示器</span><br><span class="line">hdmi_group&#x3D;2</span><br><span class="line"></span><br><span class="line">#HDMI输出的分辨率及刷新频率</span><br><span class="line">hdmi_mode&#x3D;9</span><br><span class="line"></span><br><span class="line">#禁止树莓派检测显示器分辨率，直接使用配置文件中制定的分辨率输出</span><br><span class="line">hdmi_ignore_edid&#x3D;0xa5000080</span><br><span class="line"></span><br><span class="line">#禁止黑边</span><br><span class="line">disable_overscan&#x3D;1</span><br><span class="line"></span><br><span class="line">附：常用的分辨率配置</span><br><span class="line">hdmi_mode&#x3D;4    640x480   60Hz</span><br><span class="line">hdmi_mode&#x3D;9    800x600   60Hz</span><br><span class="line">hdmi_mode&#x3D;16   1024x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;23   1280x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;32   1280x960  60Hz</span><br><span class="line">hdmi_mode&#x3D;35   1280x1024 60Hz</span><br><span class="line">hdmi_mode&#x3D;39   1360x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;47   1440x900  60Hz</span><br><span class="line">hdmi_mode&#x3D;81   1366x768  60Hz</span><br><span class="line">hdmi_mode&#x3D;82   1920x1080 60Hz</span><br></pre></td></tr></table></figure></li><li>保存、重新插上Raspberry Pi，重新开机，点亮</li></ol></li></ul><hr><h2 id="网络连接问题"><a href="#网络连接问题" class="headerlink" title="网络连接问题"></a>网络连接问题</h2><p><del>待更新，不断补齐，咕咕咕</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我也要和TCP握手</title>
      <link href="/article/tcp/"/>
      <url>/article/tcp/</url>
      
        <content type="html"><![CDATA[<p>迎新真好笑，还是充实自己<br>多次在网上看见面试时问到的TCP三次握手问题，都是看了个大概罢了，这两天好好理解了一下<br><a id="more"></a></p><h1 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h1><blockquote><p>TCP（Transmission Control Protocol）全称：传输控制协议  </p><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议.<br>TCP 要求在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等.</p><h2 id="TCP长啥样"><a href="#TCP长啥样" class="headerlink" title="TCP长啥样"></a>TCP长啥样</h2><p><em>注：主要是TCP报文头部</em><br><strong>如下图：</strong><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E6%8A%A5%E5%A4%B4.png" alt="TCP报头"></p></blockquote><p>其中：  </p><ul><li><p>源端口和目的端口：各占2个字节(16位)，分别写入源端口和目的端口.</p></li><li><p>序号：占4个字节(32位)，序号是本报文段发送的数据组的第一个字节的序号。TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 100 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从200开始。序号确保了TCP传输的有序性.</p></li><li><p>确认号(即ACKnum)：占4个字节(32位)，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。</p><blockquote><p>例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确地收到了A发送的直到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701.<br>确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0.</p></blockquote></li><li><p>首部长度/数据偏移：占4位(32位)，它指出TCP报文的数据距离TCP报文段的起始处有多远</p><blockquote><p>由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值.</p></blockquote></li><li><p>保留：占6位，保留今后使用，但目前应都位0.</p></li><li><p>紧急URG：占2字节(16位)，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据.</p></li><li><p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。TCP规定，在<strong>连接建立后所有报文的传输都必须把ACK置1</strong></p></li><li><p>推送PSH：占1位，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p></li><li><p>复位RST：占1位，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p></li><li><p>同步SYN：占1位，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</p></li><li><p>终止FIN：占1位，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</p></li><li><p>窗口：占2字节(16位)，指的是通知接收方，发送本报文你需要有多大的空间来接受；</p></li><li><p>检验和：占2字节(16位)，校验首部和数据这两部分；</p></li><li><p>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</p></li><li><p>选项，长度可变，定义一些其他的可选的参数。</p></li></ul><p><strong>一系列数据下来，TCP的首部固定为20字节</strong></p><h2 id="运作方式"><a href="#运作方式" class="headerlink" title="运作方式"></a>运作方式</h2><p>介绍完了TCP，我们来看一下TCP的三个阶段，<br>TCP协议的运行可划分为三个阶段：  </p><ol><li>连接创建(connection establishment)</li><li>数据传送（data transfer）</li><li>连接终止（connection termination)  </li></ol><p>这篇文章主要叙述的是 <strong>连接创建</strong>与<strong>连接终止</strong> 两个阶段，也就是TCP的三次握手与四次挥手两个环节.</p><h2 id="创建通路-三次握手：Three-way-handshake"><a href="#创建通路-三次握手：Three-way-handshake" class="headerlink" title="创建通路(三次握手：Three-way handshake)"></a>创建通路(三次握手：Three-way handshake)</h2><ul><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，服务器就进入了 <code>LISTEN</code> 状态</li></ul><ol><li><p><strong>第一次握手(SYN=1, seq=x):</strong><br> TCP客户进程也先创建传输控制块TCB，然后向TCP服务器发出连接请求报文。  </p><p> 这时报文首部中的同部位 <code>SYN=1</code>，同时选择一个初始序列号 <code>seq=x</code>，此时，TCP客户端进程进入了 <code>SYN-SENT（同步已发送状态）</code> 状态。  </p><p> TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p></li><li><p><strong>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</strong><br> TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1</code>，<code>SYN=1</code>，确认号是<code>ACKnum=x+1</code>，同时也要为自己初始化一个序列号 <code>seq=y</code>。  </p><p> 此时，TCP服务器进程进入了<code>SYN-RCVD（同步收到</code>）状态。这个报文同样不能携带数据，而且要消耗一个序号。</p></li><li><p><strong>第三次握手(ACK=1，ACKnum=y+1)</strong><br>TCP客户进程收到确认后，还要向TCP服务器给出确认。确认报文的<code>ACK=1</code>，<code>ACKnum=y+1</code>，自己的序列号<code>seq=x+1</code>.  </p><p> 此时，TCP连接建立，客户端进入<code>ESTABLISHED（已建立连接）</code>状态。  </p><p> TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p></li></ol><ul><li>当服务器收到客户端的确认后也进入<code>ESTABLISHED</code>状态，此后双方就可以开始通信了<h3 id="TCP为何要三次握手，两次呢"><a href="#TCP为何要三次握手，两次呢" class="headerlink" title="TCP为何要三次握手，两次呢"></a>TCP为何要三次握手，两次呢</h3><strong>以上就是大家经常谈到的TCP三次握手的内容，同时还会引申出很多奇奇怪怪的问题，比如</strong><ul><li>为什么TCP需要三次握手？如果只有两次呢？后果是什么？<blockquote><p>如果使用两次握手有可能会出现这种情况：<br>客户端发送第一次的连接请求后，因为连接请求报文丢失而未收到确认，所以再次发送了一次请求，最后这次请求成功建立，并在数据传输完成后释放连接。<br>如果第一次的连接请求只是在某个网络节点上滞留了一段时间且在第二次连接释放以后的某个时间才到达服务端，造成服务端误以为是客户端发起的新的请求，于是向客户端发出确认报文段，同意建立连接(未采用三次握手)，新的连接又再次建立，此时客户端忽略服务端发来的确认，也不向服务端发送数据，造成服务端一直等待客户端发送数据，浪费大量服务端资源.</p></blockquote></li></ul></li></ul><h2 id="终结通路-四次挥手-Four-way-handshake"><a href="#终结通路-四次挥手-Four-way-handshake" class="headerlink" title="终结通路(四次挥手 Four-way handshake)"></a>终结通路(四次挥手 Four-way handshake)</h2><p><strong>四次挥手也称作改进的三次握手，客户端或者服务器均可发起主动挥手动作</strong></p><ul><li><p><strong>第一次挥手(FIN=1，seq=x)</strong><br>假设客户端想要关闭连接，可以向服务端发送一个报头FIN=1的包，表明自己已经没有数据可以发送了，但是仍可以接收数.  </p><p>发送完毕后客户端进入 <code>FIN_WAIT_1</code> 状态,</p></li><li><p><strong>第二次挥手(ACK=1，ACKnum=x+1)</strong><br>服务器端确认客户端的 FIN 包，发送一个确认包，报头<code>ACK=1</code>，<code>ACKnum=x+1</code>，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接.  </p><p>  发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p></li><li><p><strong>第三次挥手(FIN=1，seq=y)</strong><br>服务器端准备好关闭连接时，向客户端发送结束连接请求，报头<code>FIN=1</code> .</p><p>  发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK.</p></li><li><p><strong>第四次挥手(ACK=1，ACKnum=y+1)</strong><br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 <code>ACK</code> 包。</p><p>  服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><blockquote><p>如果客户端等待了某个固定时间（两个最大段生命周期，<code>2MSL</code>，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p></blockquote></li></ul><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p><strong>四次握手中也有问题，比如最后一次握手后，主动提出断开连接的一方需要再等候<code>2MSL</code>，为什么？</strong>  </p><blockquote><p>我们再看一遍简化的四次挥手：  </p><ol><li>首先主动发起断开连接请求的A向服务端发送<code>FIN=1</code>的报文</li><li>服务端收到A的报文，回复<code>ACKnum</code></li><li>等待一段时间，B发出<code>FIN=1</code>的报文<br>此时B还不能释放资源，因为它需要确认A收到了<code>ACKnum</code>与<code>FIN=1</code>，所以还需要等待A发送的最后一个消息：<code>ACKnum</code></li><li>A发出最后一条消息，B成功收到  </li></ol><ul><li>当B收到A最后发来的消息时：<br>在B的视线内B认为双方已经达成了同步，都可以释放资源并关闭连接了，此时B释放此次TCP连接占用的资源以及端口。所以B(服务端)无需产生wait time，直接释放.</li></ul></blockquote><ul><li>但在A看来，发出最后一条消息后，因为已经是四次挥手的最后一次，所以A没有办法确认B是否收到了这条消息，所以A会做出两种假设：  <ol><li>B没有收到<br> B会超时重新传递FIN，A接受到后，会重新发送ACKnum</li><li>B收到了<br> 不会回复任何消息，需要一个相对安全的wait time确保B已经收到  </li></ol></li></ul><blockquote><p>出现的A等待<code>2MSL</code>就是取这两种情况等待时间的最大值，以应对最坏情况，来确保TCP连接的正常关闭<br><strong>最坏情况就是:去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL) = 2MSL</strong></p></blockquote><ul><li><p>等待<code>2MSL</code>后，A就可以安心释放TCP占用的资源、端口。如果不等：  </p><p>  释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部失效。</p></li></ul><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul><li><p>什么是SYN攻击<br>在三次握手中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 ACK 之前的 TCP 连接称为<code>`半连接(half-open connect)。此时服务器处于</code>SYN_RCVD<code>状态。当收到 ACK 后，服务器才能转入</code>ESTABLISHED` 状态.</p><p>SYN 攻击指攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。<br>由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>  SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></li><li><p>怎么检测SYN攻击<br>如果在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p></li><li><p>如何防御 SYN 攻击<br>SYN攻击不能完全被阻止，除非将TCP协议重新设计。但可以减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重庆三日游</title>
      <link href="/article/travle/"/>
      <url>/article/travle/</url>
      
        <content type="html"><![CDATA[<p>2020-7-21~23的重庆三日游已经结束啦！<br>记录下我们的行程和去重庆的回忆.<br><a id="more"></a></p><h1 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h1><p><del>2020-7-21~23会去重庆旅游三天，现在正在规划行程呢，选了一些景点和小店，留在这儿看方便一点。<br>后续还会添加一些地点Maybe，还会更新出完整的重庆游方案以及部分照片</del>。</p><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><ul><li><strong>千厮门大桥</strong></li><li><strong>洪崖洞</strong><br><em>Location:重庆市渝中区嘉陵江滨江路88号</em></li><li><strong>龙门浩老街</strong><br><em>Location:南滨路105号</em></li><li><strong>解放碑</strong><br><em>Location:邹容路100号</em></li><li><p><strong>白象居</strong><br><em>Location: 渝中区白象街1-6号</em></p></li><li><p><strong>来福士广场</strong><br><em>Location： 渝中区铁板巷6号</em><br><em>Pic： 渝中区铁板巷8号</em>  </p></li></ul><hr><h2 id="探店"><a href="#探店" class="headerlink" title="探店"></a>探店</h2><ul><li><p><strong>三浮冰事</strong><br><em>Location：重庆市渝中区大坪正街大坪龙湖时代天街D馆12栋1楼</em></p></li><li><p><strong>Mist Castle</strong><br><em>Location:重庆市渝中区大坪正街大坪龙湖时代天街B馆4号楼14-16</em></p></li><li><p><strong>Wormhole Vintage</strong><br><em>Location：大坪正街大坪龙湖时代天街A馆时代星空1栋1224</em></p></li><li><p><strong>The Place食也·灶咖</strong><br><em>Location：黄龙路朗俊中心4幢1-商业9(豪谛酒店对面)</em></p></li><li><p><strong>失重餐厅</strong><br><em>Location:来福士广场商场四层001号</em></p></li><li><p><strong>饭粑砣</strong><br><em>Location：较场口89号得意世界c区1-2号</em></p></li></ul><hr><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><ul><li><p><strong>长江索道</strong><br><em>Location：新华路151号</em></p></li><li><p><strong>探索舱·观景台</strong><br><em>Location：接圣街8号(重庆来福士14号门)</em>  </p></li></ul><hr><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><ul><li><strong>Day1.<br>到达后：下高铁——午餐——民宿(3pm)<br>下午：三浮冰事——Wormhole Vintage——Mist Castle<br>晚餐：寿喜烧<br>晚上：逛街</strong></li><li><p><strong>Day2.<br>早上：解放碑逛街<br>午餐：饭粑砣<br>下午：白象居拍照——长江索道——龙门浩老街拍照<br>晚餐：龙门九号火锅<br>晚上：洪崖洞、千厮门大桥——回民宿</strong></p></li><li><p><strong>Day3.<br>早上：来福士广场<br>午餐：失重餐厅<br>下午：探索舱·观景台———朝天门广场<br>晚餐：the place食也·灶咖<br>晚上：动车回家</strong></p></li></ul><hr><h1 id="详细感受"><a href="#详细感受" class="headerlink" title="详细感受"></a>详细感受</h1><p>此板块下分为了对重庆的各方面感受，还有旅行中的感受 .</p><h2 id="1-天气方面"><a href="#1-天气方面" class="headerlink" title="1. 天气方面"></a>1. 天气方面</h2><ul><li>说实话刚到重庆时的闷热是能明显感受到的，虽然当天没有出太阳是晴天，但是能明显感受到没有阵阵自然风吹来，整个的感受就是闷热。<br>前两天（21、21）的天气情况对外乡人来讲都还可以，不是很热，但是第三天气温回升的重庆还是让我们体验了一把重庆的热。第三天的天气在傍晚的时候也发生了变化，我们出 来福士 的时候下起了大雨，还不得不在Miniso买了两把雨伞。走到室外时，那种感受我承认是第一次，滚烫的地板刚沾了难得的雨水，街道上到处都散发着一股闷的味道，很是难忘。</li></ul><h2 id="2-人文方面"><a href="#2-人文方面" class="headerlink" title="2. 人文方面"></a>2. 人文方面</h2><ul><li>重庆人给我的第一感受就是：野性、豪爽，那边的口音能让我听着有一种亲切感，因为我老家的口音和重庆口音比较类似，交流起来也不需要用普通话，比较方便。  </li></ul><h2 id="3-饮食方面"><a href="#3-饮食方面" class="headerlink" title="3. 饮食方面"></a>3. 饮食方面</h2><ul><li>其实川渝地区的口味都相差不是很大，我们同行的人都比较能吃辣，应付重庆的菜不在话下</li></ul><h2 id="4-住宿方面"><a href="#4-住宿方面" class="headerlink" title="4. 住宿方面"></a>4. 住宿方面</h2><ul><li>去外地城市旅游首选肯定是民宿了，这次的民宿找了两天，终于选定了一家有3卧、临江还便宜的民宿。<br>不过肯定有一些缺点，首先是民宿有一点老旧，其中的一些小细节方面体验不是非常好，比如所卫生间设计的有点奇怪，卧室的被套上有一些水臭，除了这些外整体体验都非常不错。<br><del>（2晚每个人付200左右，不要太便宜）</del></li></ul><h2 id="5-城市印象"><a href="#5-城市印象" class="headerlink" title="5. 城市印象"></a>5. 城市印象</h2><ul><li>8D!8D!8D!<br>在重庆最让我疑惑的问题是“我在第几层”，从我们的第一楼爬了一段很高的楼梯，上去后告诉我是在-3楼…<br>从我们的第一楼进去后看路标是在4楼…<br>呜呜呜呜呜！老千层饼了</li></ul><h1 id="相关照片"><a href="#相关照片" class="headerlink" title="相关照片"></a>相关照片</h1><p><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E5%A4%A7%E6%A1%A5.jpg" alt="东水门大桥"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E5%88%A8%E5%86%B0.jpg" alt="三浮冰事"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E5%B0%8F%E5%90%83.jpg" alt="小吃"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E9%85%B8%E5%A5%B6.jpg" alt="酸奶"><br><img src="https://codgi-hexo.oss-cn-beijing.aliyuncs.com/pic/%E9%A5%AD.jpg" alt="食也">  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>现在由Sheey帮我托管博客啦</title>
      <link href="/article/update/"/>
      <url>/article/update/</url>
      
        <content type="html"><![CDATA[<p>困扰了许久的问题终于解决了<br><a id="more"></a></p><h2 id="gt-前言：有时候和Sheey聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。"><a href="#gt-前言：有时候和Sheey聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。" class="headerlink" title="&gt; 前言：有时候和Sheey聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。  "></a>&gt; 前言：有时候和<a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a>聊天的时候他经常提到我的博客访问不到，Ping也Ping不通，有时看一些东西造成了很大的困扰。  </h2><ul><li><p><a href="https://codgi.xin">Codgi的小窝</a>在Github上开启了静态页面托管，奈何隔了半个地球的服务器对大陆地区一部分用户不友好，遂换到了鹅厂的Coding托管，这下访问速度不成问题了，但是出现了隔三岔五的就会访问不上。</p></li><li><p>最近<a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a>提出来了帮我托管，在犹豫了半天后发现访问还是有问题，最后实在忍不了了就让他帮我托管啦，这下访问就没有问题了，蟹蟹 <a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a> 大佬的帮助.  </p></li></ul><p>遇到的问题：这篇文章是在<a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a>帮我托管后所发的第一篇文章，当天已经很晚了，我使用<code>hexo g -d</code>后发现没有及时更新，<a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a>大佬告诉我是5mins抓取一次，索性也就没管了。  </p><p>几天后我发现还是没有更新，然后找到了<a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a>，一番排查后发现这个问题也是他曾经遇到过的…——&gt;<a href="https://sheey.moe/article/build-blog-online" target="_blank" rel="noopener">在服务器上持续化 build blog</a></p><p>最终提出的发布方案：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">cd public</span><br><span class="line">git add</span><br><span class="line">git commit -m 'update'</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><br>测试后没有问题了<br><strong>以上</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>赚钱 Or 学习</title>
      <link href="/article/makemoney/"/>
      <url>/article/makemoney/</url>
      
        <content type="html"><![CDATA[<p>大学生活已经过去了一年，由于特殊的疫情，今年我们不得不在家待了半年，很多同学借着此次机会，外出兼职、打工、摆地摊，也是<br>赚到了人生中的第一桶金。我也不例外，赚到了人生的第一桶金：x RMB，量级为K，但是却跟他们不一样，这次写写大学生赚钱那些事。<br><a id="more"></a></p><h1 id="大部分的赚钱方式"><a href="#大部分的赚钱方式" class="headerlink" title="大部分的赚钱方式"></a>大部分的赚钱方式</h1><p>打开知乎，搜索框内键入“赚钱”关键字，然后回车，你所看到的答案清一色的有以下几种：网赚、写手、二手、投稿、自媒体、问答、问卷、App体验。<br>各种回答把上面的几种赚钱方法吹得神乎其神，放几张自己存款的截图，然后就硬吹，赚钱方法人家会选择自己最合适的，但是坑却不会告诉你。</p><hr><h2 id="靠网赚"><a href="#靠网赚" class="headerlink" title="靠网赚"></a>靠网赚</h2><p>这种赚钱方式我不想聊，很多，比如淘宝刷单类、淘宝客类、做网络直播、短视频类等，但是结合一下自身的实际情况，有多少大学生是符合这个网赚的要求的？<br>还有说打字就能赚钱的，要真这么简单他为啥会给你做呢？<br><strong>有赚到钱的，但是不固定</strong></p><h2 id="做写手"><a href="#做写手" class="headerlink" title="做写手"></a>做写手</h2><p>在淘宝找个店家，然后私聊客服说可以做写手，又或者专门加那种写手的QQ群。要加入他们当一名写手你需要经过如下过程：  </p><ol><li>通过他们设计的考试（设计的考试很扯淡，而且通过率很低</li><li>叫你先写几份文稿看下</li><li>（可能会叫你交入会费）</li></ol><p>如果你成功加入了他们，开始了你的写手“赚钱”日子，你发现做一名写手好像没那么容易赚钱。<br>首先不谈写手的效率问题，有哪个业余的写手能保证自己拿到单子后都有明确的思路和写出很好的文章，大部分招写手的都是有任务后发给写手做，然后筛选出比较好的文章交工。<br>如果你文采足够好，恰好脱颖而出了一下，结账的时候发现自己当了黑奴：1000字20~50rmb，然后又会百般刁难你，最后你拿到的钱就只有那少少的几十块，几乎是做了免费的劳动力，赚钱全是人家的。  </p><p><em>如果这条你不信的话可以去亲身体验下</em>  </p><h2 id="卖闲置"><a href="#卖闲置" class="headerlink" title="卖闲置"></a>卖闲置</h2><p>敢问在座的学生党家里具体有多少闲置的物品，许多年前的手机、数码产品、过时的小物品，放在咸鱼上其实是买不到多少钱的。而且在家闲置的物品说不定你哪个时候还能用上，靠卖二手物品不能算作真正意义上的“赚钱”，而是用一物换一物。  </p><p>看到这儿许多人又会问了：我去薅羊毛、捡垃圾，然后再把这些东西在二手平台上卖掉，不是还是可以赚钱吗，而且基本是原价赚。确实是现在大多数人把赚钱想得太简单了，铺天盖地的什么“神车群”、“捡漏群”让你加。那事实是什么呢： </p><ol><li>群里会有真正的“神车”，但是你未必能抢到，需要时不时就看一下消息</li><li>群里面发的几分钱几角钱抢一个很高价的物品的图大概率是P的</li><li>群内的推送不是真正的BUG、漏洞，而是和商家联系好了的推广链接</li></ol><p>现在都不流行薅羊毛了，喜欢薅薅羊毛的人，进群发现要蹲的东西都没有，买了几个盗版、杂牌货还以为自己赚了，卖不出去还给人家赚了佣金。也不想想为什么这种群还需要推广，如果真的如他们说的那么美好，岂不是自己闷声发大财。<br>家里如果不是真有不用的闲置物品，或者你想靠薅羊毛倒卖赚钱的话还是打消这个想法吧。</p><h2 id="瞎投稿"><a href="#瞎投稿" class="headerlink" title="瞎投稿"></a>瞎投稿</h2><p>跟写手一个性质，不过这个更像以后你投出去的简历没了后续  </p><h2 id="自媒体"><a href="#自媒体" class="headerlink" title="自媒体"></a>自媒体</h2><p>这里指的头条号、企鹅号、大鱼号等自媒体网站，这里真的别做了，到现在这个阶段你一个人没法做了，而且成不了的，看一下网上整理出来的数据吧：</p><blockquote><p>头条号：1W阅读量 1元 （量大，一般一篇文章能有几千的阅读）<br>企鹅号：1W阅读量 1元 （量小，一般一篇文章阅读量只有几百）<br>大鱼号：1W阅读量 1.5-2元 （量小，一般一篇文章阅读量只有几百）<br>百家号：1W阅读量 10-15元 （量中，一般一篇文章阅读量几百到几千，开通收益条件苛刻）  </p></blockquote><p>现在的基本情况就是做自媒体的人比看自媒体的人都还多，还怎么玩？  </p><h2 id="填问答、问卷"><a href="#填问答、问卷" class="headerlink" title="填问答、问卷"></a>填问答、问卷</h2><p>可能大部分人还不知道这个也可以赚钱，也是，问题搜都搜不出来、答对了的回报还少，还有许多工作室的存在，从人家嘴巴里抢肉还是嫩了点。<br>常见的问答平台的报价：</p><blockquote><p>悟空问答：现在基本没有收益了<br>芝麻问答：回答一个问题0.2元，一个月开原创后2元，原创需要300字加图片<br>How问答：回答一个问题0.5元，回答需要审核，通过率很低，审核速度巨慢  </p></blockquote><p>上面的我也亲自去做过一次，当时还没遭受过毒打，以为去网上搜一下就能轻松地赚到钱，结果现实给了我迎头一棒。</p><h2 id="下App"><a href="#下App" class="headerlink" title="下App"></a>下App</h2><p>众人帮、赚钱了等等App，本质就是你下载App赚钱，你可知道下载一个只有0.05-0.2元，不仅如此还需要注册体验3分钟才行，这钱真的有赚的价值和必要？？不仅如此，提取现金还需要门槛，门槛很高，也是30元才能提取现金，是真难做。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面写的几种常见的赚钱方法的真实面目可能会打击你赚钱的信心，但是现实就是这样，网上赚钱方法遍地走，就仿佛在逛90年代的香港，遍地是黄金，满街都是女人。<br>真正的赚钱方法永远是掌握在真正赚钱的人的手中，这么可能会随随便便就分享给网上素不相识的人，如果有那真是脑袋抽了，自己给自己找对手。<br>真正赚到钱的人都是有恒心自己去把答案找出来的那些人。<br>别人的答案帮不了你，你得自己花时间。  </p><h2 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h2><p>好好学习</p><p>国奖：8000</p><p>励志奖学金：5000</p><p>一等奖学金：1500</p><p>三好与优干：1000</p><p><strong>学习好在大学以前是省钱，上大学后学习后确实赚钱</strong><br><strong>或者给自己培养个兴趣，找到合适的机会将自己的技能或者知识变现也是个不错的选择</strong><br><strong>如果硬要我选，学习真tm香</strong>  </p><p>灵感来源：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=57285232&bvid=BV1gx411R7ke&cid=99998982&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哪个男孩不想要好用的网盘</title>
      <link href="/article/clouddrive/"/>
      <url>/article/clouddrive/</url>
      
        <content type="html"><![CDATA[<p>pandownload的作者前几天的时候刚被抓捕，法律规定模糊不清，没有审判标准，直接定罪。<br>做一款好的云盘究竟有多难？<br><a id="more"></a></p><h1 id="网盘那些事"><a href="#网盘那些事" class="headerlink" title="网盘那些事"></a>网盘那些事</h1><h2 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>绝大部分数据是存放在数据中心内的，一个典型的数据中心内，你可以看到一排排机柜，机柜里是机架式服务器，服务器里插着硬盘，存放的文件就在这里面<br>服务器是数据中心的基本单位，每台服务器都有独立的CPU和内存，以及其他必须硬件，用于接收上传和下载请求。</p></li><li><p>衡量一台服务器大小的单位是U，常见的尺寸有1U、2U、4U，每1U表示服务器的高度是4.445cm，当然，尺寸越大装的硬盘也就越多。<br>每台机柜的高度大部分是42U，能够并排放进16台1U的服务器，数据中心里每100平方米可以放进20台机柜，这样每100平方米<br>可以放下20x16x4x8 差不多1万 TB的硬盘</p></li></ul><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><ul><li><p>如果这台服务器只服务于极少数的人，那么要实现不难<br>难的是在成千上万个人同时下载的时候，还能够保持高速，这时就需要将文件分块,<br>比如一个大小1G的文件，我们可以切分成1024块1M大小的文件块，分布到多台服务器内</p></li><li><p>当接受到下载请求后，数据中心首先会访问元数据服务器，反馈出下载对象储存在哪些服务器内<br>然后用户会直接访问相应服务器内的相应内容，读取数据，但是仅仅这样做还是不够</p></li><li><p>今天，云存储服务还都提供了CDN支持，<br>CDN相当于你和数据中心之间的缓存，能够极大的缓解数据中心的压力</p></li></ul><h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><blockquote><p>不仅仅是网盘，我们访问的绝大多数服务器都需要数据中心的支持，我们可以在百度、腾讯、阿里云等提供云服务平台上<br>详细的找到他们对于数据存储的定价，大概的价格是0.15元/GB/月，按照这个价格可以算出来存储1T的数据一年旧的花1800元<br>为什么价格这么高，首先我们需要知道数据中心主要有哪些开销</p></blockquote><ol><li><p>硬件成本<br> 以百度阳泉数据中心为例，里面共有16万台服务器，总共可以存储大概6000 PB，也就是614万 TB的数据，假设都使用8TB x 18<br> 规格的存储服务器，则将近会使用4.27万个存储服务器，按每块8TB 硬盘2000，每台服务器一万元来粗略计算，光是前期投入的硬件<br> 成本就得19.6亿元，换算一下就是319.5元/TB</p></li><li><p>电费开销<br> 即使是在<strong>非常节能</strong>的“北极”整机柜中，每6台服务器就需要1个2400W的电源进行集中供电，那么该数据中心每小时就<br> 要消耗6.4万度电来运转所有的服务器，按照阳泉市0.45元/度 的商业用电标准，一年的电费还会烧掉2.5亿元</p></li><li><p>还有网费<br> 数据中心为了提供云存储服务，需要向三大运营商缴纳约10万元/GB/月的专线接入费用，按中国数据中心的平均出口带宽<br> 332GB来计算，每年还要缴4亿的网费</p><p><strong>这样看来，提供云存储服务是真的很贵，不算上初次投入以及其他花销，每年光是电费网费就得6.5亿元</strong></p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>不考虑每年的硬件损耗，阳泉数据中心每存储1TB 的数据，每年在电费和宽带上的钱也需花费105.7元/TB</p></li><li><p>高额的运营成本，让很多的网盘服务都纷纷倒闭，目前的网盘收费方式主要有购买空间和购买会员两种方式<br>iCloud和Dropbox是典型的空间购买型网盘，2TB空间每年要花费816元人民币</p></li><li><p>如果不想花这么多钱，你也可以选择免费都有2TB的百度网盘，但免费也有免费的问题，无论你家网速多块，只要不是会员都会被限速下载，<br>毕竟服务商也是要赚钱的</p></li><li><p>以阳泉数据中心为例，即使每年交4亿元网费，在不限速的情况下，332GB的带宽也只能够支持6W人以700K每秒<br>的速度下载，非常紧张，如果保证有1W名会员能够以3.9M每秒的速度下载，剩下的免费用户的下载速度只有50K每秒了<br>这样节约了成本，也增加了付费点: 充值会员开启高速下载，毕竟每1TB的运营成本就得106元，如果不想想办法的法就只能像其他<br>网盘一样倒闭了</p></li></ul><h2 id="百度云盘"><a href="#百度云盘" class="headerlink" title="百度云盘"></a>百度云盘</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>百度网盘，曾用名百度云（Baidu Cloud），是百度推出的一项个人云存储服务，覆盖中国大陆各大主流电脑和手机操作系统，包含Web版、Windows版、Mac版、Android版和iPhone版。用户可以将自己的文件上传到网盘上，并可跨终端查看和分享。在百度创建开放云后，合并为平台分布式私人储存服务。当前，百度网盘已成为了中国大陆最大的网盘服务商之一</p></blockquote><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p><strong>评价分为正反两方面</strong></p><ul><li><p>正面:</p><p>百度网盘免费提供2TB网盘空间，支持网盘之间好友相互共享文件，并且支持离线下载，受到用户的欢迎与使用</p></li><li><p>负面:</p><ol><li><p><strong>用户隐私问题</strong></p><p> 2017年7月18日，自媒体用户发文称，因为用户通过百度网盘公开分享的文件可以被所有人任意阅览与下载，所以在一些第三方网盘搜索网站上也可以搜索到这些文件，其中就有网盘用户通过公开方式分享的个人照片、通讯录等涉及个人信息的文件，这也造成了一定程度上用户隐私泄露的隐患</p></li><li><p><strong>净网行动</strong></p><p> 因为百度网盘的文件分享功能便利，不少用户利用其传播一些在中华人民共和国的境内网站受到限制的内容，例如色情内容，因此百度网盘曾经被中国大陆相关部门约谈。自2014年起，百度网盘几乎每年都响应中华人民共和国全国“扫黄打非”工作小组办公室主办的“净网”专项行动，对用户上传的文件进行自我审查，删除某些在中国大陆境内的受限内容</p><blockquote><p>百度网盘将对用户上传、存储、分享的色情淫秽、暴恐等不良信息以及涉侵权的文件继续加大清理力度。对于相关的不良信息及严重违规账号，将采取全面清理、永久封禁的措施</p></blockquote><p> 2014年的扫黄打非·净网2014期间，很多用户发现自己网盘中的一些视频被替换成“8秒百度云净网行动公告”（俗称“8秒教育片”），被替换的视频大部分是涉黄视频，也包含其他类型的视频。不少用户抱怨百度网盘未尽保护用户上传数据隐私的责任。为了绕过审查机制还出现了一些新的上传手段</p></li><li><p><strong>下载限速</strong><br> 百度推出“超级会员”开始，便陆陆续续有用户反映百度网盘限制了普通用户和普通会员用户的下载速度<br> <strong>而百度网盘官方否认这种行为，在百度网盘的FQA中，出现过以下内容：</strong></p><blockquote><p>Q:使用百度网盘PC客户端下载\上传遇到失败、中断、速度慢、路径无效、无权限，怎么办？<br>A:网盘客户端上传下载速度均未做任何限速，原则上速度取决您带宽大小</p></blockquote><p> <strong>这也是后面a发生事情的开端</strong><br> 部分用户因此抨击百度网盘，亦有不少用户因此开发了各种尝试破解百度网盘限速的方式。对此，2018年4月，百度网盘采用了封杀非官方版本的方式进行应对，使用非官方版本下载网盘文件，将会出现失败的情况。更进一步的，如果帐号存在大量异常请求，将会被锁定</p></li><li><strong>部分地区的服务限制</strong><br> 百度网盘的分享链接会选择性地屏蔽部分地区的IP（例如新疆和台湾），这些地区的用户在尝试下载百度网盘分享链接中包含的资源时会跳转至链接已经失效的页面（“啊哦，你所访问的页面不存在了”）；但如果使用VPN打开分享链接，则可以正常下载</li></ol></li></ul><h2 id="Pandownload"><a href="#Pandownload" class="headerlink" title="Pandownload"></a>Pandownload</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>  Pandownload于2017年2月19日上线，是一款在百度网盘的基础下提供的不被百度认可的第三方百度网盘下载软件。PanDownload可以在Windows和Android系统上使用，另外还有Web版（仅提供解析百度网盘文件下载链接功能）。用户可以通过PanDownload实现百度网盘文件的高速下载</p><h3 id="发生事件"><a href="#发生事件" class="headerlink" title="发生事件"></a>发生事件</h3><p>  <strong>2020年4月15日，PanDownload的作者因涉嫌提供侵入、非法控制计算机信息系统的程序、工具罪被逮捕</strong></p><p>  下面是“官方版”：</p><blockquote><p>经查：2017年，犯罪嫌疑人在家中编写可以通过百度网盘官方服务器的客户端身份认证，实现以非会员权限突破百度网盘官方设定，高速下载Pandownload软件，并在互联网上发布。期间犯罪嫌疑人租用网络服务器进行更新维护并发布接受捐赠的收款码，同时建立QQ群，向进群人员收取1至10元不等的进群费，群内提供更稳定的 Pandownload内测版本。截至案发，犯罪嫌疑人非法获利30万余元</p></blockquote><ul><li>与此同时，PanDownload的官网已不可用，其Windows版软件在启动时报“http请求错误 0x1c”或“http请求错误 0x38”，Android软件启动时报“本软件已停用”</li></ul><h2 id="如何去理性看待"><a href="#如何去理性看待" class="headerlink" title="如何去理性看待"></a>如何去理性看待</h2><ul><li><p>在百度云免费提供给我们2T空间的同时(但目前听说新用户没有2T这么多)，为我们提供免费的云存储服务这件事上确实是好的，这种东西只能自己独立去思考，百度网盘到底是什么地方做错了</p></li><li><p>你可以去选择其他的云盘，而当你的好兄弟，好同学把他的资源发给你时，你发现大多数人都在用百度网盘</p></li><li><p>Pandownload 并不被认可，同时有一点激进</p></li></ul><h2 id="深入探讨下百度网盘-amp-Pandownload"><a href="#深入探讨下百度网盘-amp-Pandownload" class="headerlink" title="深入探讨下百度网盘&amp;Pandownload"></a>深入探讨下百度网盘&amp;Pandownload</h2><ol><li><p>首先，百度网盘的体验确实是很差，流氓客户端 + 不尊重用户数据隐私 + 精准限速(限速并不是什么见不得光的事情，还有不少网盘限流呢，大大方方说出来就好)</p></li><li><p>那么如果你想要体验好的网盘呢？ 上面粗略地叙述了一下iCloud和Dropbox的价格，我们再将价格细化，多加入几个云服务厂商</p><ul><li><p>苹果 iCloud：<br>折合人民币 50GB/80¥，200GB/250¥，2TB/850¥ 每年<br>（50 GB/12$ 200GB/36$ 2TB/120$）</p></li><li><p>谷歌 Google Drive：<br>折合人民币 100GB/140¥，200GB/210¥，2TB/710¥ 每年<br>（100GB/20$ 200GB/30$ 2TB/100$）</p></li><li><p>Dropbox：2TB/850¥ 每年:<br>（2TB/120$）</p></li><li><p>Mega：400GB/460¥（限流 1TB 每月），2TB/922¥（限流 2TB 每月） 每年<br>（官网提供了人民币售价）</p><p><strong>这里面有个例外：Microsoft Onedrive</strong></p></li><li>假设你跟其他人凑成了家庭版合租，那么基本上是 1TB/50¥ 每年。<br>但 Onedrive 的速度跟上面其他服务商的速度差了不少。<br>除了微软这种赔本赚吆喝的厂商之外，2TB 存储基本售价均在 700 人民币每年往上。<br>这还是建立在这些资本主义国家云计算资源比较便宜的基础之上的</li></ul></li><li><p>可能国内的云储存介绍得也不够，再展开叙述下</p></li></ol><ul><li><p>因为 2C 生意这两年一直在「提速降费」，每个月几十一百就能开一个好几百兆的宽带，导致了很多人产生了大陆带宽很便宜的错觉。<br>说到底，羊毛出在羊身上。用户的下行对应的是服务商的上行。用户的下行带宽便宜到了白菜价就意味着要把这部分成本转嫁到服务商身上。<br>反正用户网卡了不会怪运营商，而是「你这什么破网站，我家 1000Mbps 的网看个 1080p 都卡」。</p></li><li><p>拿阿里云 ECS 为例，一条 200Mbps 杭州地区商宽的价格是折后 160000 一年，平均每个月的价格是 15000 元。<br>按量计费的价格则是 0.8元/G，假设你带宽能连续跑满一周的话，你的流量钱实际上已经跟包月专线价格一样贵了。</p></li><li><p>我们再看看专门做文件分发的又拍云，文件存储 0.0043 元/GB/天，公网流量 0.5 元/GB，国内 CDN 流量 0.29 元/GB。</p></li></ul><p><strong>有了这些数据，我们简单地做下计算</strong></p><ul><li><p>前提： 假设你的网站有 2000 个用户，每时每刻都有 100 个（5%）用户是活跃用户，在进行上传和下载。<br>每个用户网盘有 300GiB 内容，每人网盘的内容 90% 为重复内容。那么总共产生了 60000 GiB 不重复的内容与 270GiB 共有内容。<br>每个月产生的数据存储费用大约是 7700 元左右。</p></li><li><p>算法：<br>按照包死带宽法，假设你是用 200Mbps 专线，每个用户在这时候也只能分到 2 Mbps 带宽，甚至看不了一个 720p 视频。<br>在这时，每个用户的成本大约在 12 元每月。</p><p>如果按照流量法，给每个用户分配 10Mbps 带宽（总带宽 1Gbps），每个月产生的流量费用接近 162000 元左右。<br>在这时，每个用户的成本大约在 85 元每月。</p></li></ul><p><strong>即使是自建机房，价格也不会便宜多少</strong></p><ol><li><p>反观百度网盘</p><ul><li><p>百度云的定价大约是 SVIP 200 元左右一年，2TB 存储空间，实际上这个价格非常便宜，甚至接近亏本。<br>所以这可能是导致用户体验差的原因之一，毕竟钱没赚多少，亏倒是不少亏。为了保证付费用户的下载权利，只能削减免费用户的带宽</p></li><li><p>目前出现的问题也不是免费用户了，有很大一部分人是购买了百度网盘的会员奔着去使用的，但是也出现了速度不够的问题，只能简单地判断，百度云盘是否渐渐满足不了我们这么多人的需求？</p></li></ul></li><li><p>那么我们看看Pandownload</p><ul><li>极低的价格，获得的下载速度很理想</li><li>这也是个问题，如果一个「破解加速器」收费赚钱的话，更像是屠龙的勇士最终变成了恶龙，而且屠龙的剑还是白嫖的</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为一个普普通通的使用者，我两款软件都有用过，但期间有一段时间Pandownload无法使用，百度网盘我也不想使用，所以想起了自己搭建一个Oneindex，对接onedrive，目前……也用不了了<br>对于这两个软件的看法还得自己去主观判断<br>关于Pandownload作者被抓这件事也是给了各位开发者一个警告，希望在不久以后百度网盘更好用，或者会有更好的网盘商</p><p><em>文章内容一部分摘抄自<a href="https://www.bilibili.com/video/BV1Ex411f7r4" target="_blank" rel="noopener">Paperclip:中国的网盘为什么这么难用</a>和<a href="https://t.me/misakatech" target="_blank" rel="noopener">科技圈的日常</a>,如有侵权请联系本人删除</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈游戏</title>
      <link href="/article/games/"/>
      <url>/article/games/</url>
      
        <content type="html"><![CDATA[<p>我以前也是一个网瘾男孩，总是在不该玩游戏的时候疯狂玩游戏，导致自己错过也丢失过一些东西，但现在毕业以后突然就没有网瘾了，身边发生的一些事引发了我的感想，就想写一篇关于游戏的<br>本文章包含以下元素:  </p><ul><li>介绍  </li><li>游戏可以带来什么  </li><li>游戏内的病态  </li><li>我<a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>写这篇文章的原因是因为最近玩游戏的频率大大降低了，慢慢地离开游戏后所引发的感想<h1 id="游戏的简介"><a href="#游戏的简介" class="headerlink" title="游戏的简介"></a>游戏的简介</h1><h2 id="什么是游戏"><a href="#什么是游戏" class="headerlink" title="什么是游戏"></a>什么是游戏</h2></li><li>游戏是一种基于物质需求满足之上的，在一种特定时间、空间范围内遵循某种特定规则的，追求精神需求满足的社会行为方式。游戏有智力游戏和活动性游戏之分，又翻译为 Play，Pastime，Playgame，Sport，Spore，Squail，Games，Gamest，Hopscotch，Jeu，Toy。现在的游戏多指各种平台上的电子游戏。</li></ul><h2 id="常见的游戏"><a href="#常见的游戏" class="headerlink" title="常见的游戏"></a>常见的游戏</h2><ul><li><p>RPG：全称 Role-playing game，如腾讯的《火影忍者》，目前比较火的《武林外传》手游，大型多人在线角色扮演游戏。包括一些格斗类的小游戏，都可以称为RPG</p></li><li><p>FPS：全称 First-person shooting game，第一人称射击类游戏。目前比较火爆的吃鸡游戏，很多人归为fps游戏，严格意义上划分市面上大多数吃鸡游戏应当属于第三人称射击类游戏</p></li><li><p>MOBA：全称 Multiplayer Online Battle Arena，多人在线战术竞技游戏，最著名的，Dota2，LOL</p></li><li><p>LBS：全称 Location Based Services，基于位置服务（的游戏），比较偏门，如pokemon go，属于LBS+AR玩法</p></li><li><p>RCG：全称 Racing Game 竞速游戏，如极品飞车</p></li><li><p>MSC：全称 Music Game 音乐游戏，如劲舞团、劲乐团</p></li><li><p>LVG：全称Love games 恋爱养成游戏，如秋之回忆</p></li><li><p>SPG：全称Sport games 体育运动类游戏，如FIFA2，NBA2K</p></li><li><p>AVG：全称Asymmetrical Battle Arena 非对称性对抗竞技类，如黎明杀机</p></li></ul><p><strong>#注：以上分类不完全，且列举游戏仅有一小部分</strong></p><hr><h1 id="游戏的正反两面"><a href="#游戏的正反两面" class="headerlink" title="游戏的正反两面"></a>游戏的正反两面</h1><h2 id="游戏能带给我们什么"><a href="#游戏能带给我们什么" class="headerlink" title="游戏能带给我们什么"></a>游戏能带给我们什么</h2><ol><li><strong>游戏能带给我们最多的：欢乐</strong><br>毫无疑问，游戏在大多数的青少年的成长中，是必然的存在，例如我小时候玩的赛尔号，穿越火线之类的(小学)，在当时确实给我无聊的童年生活带来了许多欢乐。</li></ol><ol><li><strong>游戏，为我们丰富了社交，打开了话题</strong><br>稍微长大一点，英雄联盟步入了我的视线，看着同学们津津乐道地叙述，以及观看他们打游戏，都让我对这款游戏产生了好奇。也是我记忆最深的一次，跟同学去小网吧打英雄联盟，<br>这款游戏给我带来的最多的就是社交，与同学之间有更多的话题，也能找到更多 <strong>“志同道合”</strong> 的朋友</li></ol><ol><li><strong>游戏能让你收获一些知识</strong><br>再到后面，你玩的游戏很少有人玩，你也找不到有人可以陪你玩，因为你玩的游戏是你喜欢的，可能是因为游戏里面的某个角色、某个剧情、或者是它的背景故事吸引着你。<br>你觉得你能从这些游戏中获取你喜欢的内容，能在某些地方开拓你的眼界，所以你玩它。</li></ol><h2 id="游戏会让我们失去什么"><a href="#游戏会让我们失去什么" class="headerlink" title="游戏会让我们失去什么"></a>游戏会让我们失去什么</h2><p>  <strong>#注：建立在过度游戏的基础上</strong></p><ol><li><p><strong>荒废学业</strong><br>这一点不需要过多地去阐述太多了，抛开你在电视上看的新闻、别人口中听说的故事，你正在看的这篇文章的作者原来就是一个十足的网瘾少年。确实因为过度地游玩游戏而在学习上荒废了太多  </p></li><li><p><strong>浪费金钱</strong><br>你是否也会为了买游戏内的一个物品，连着许多天要求自己少吃点，或者根本不吃。可能在一部分的人眼中，花自己的钱买自己想要的，i高兴就行了。我当然不能否定，因为你钱多（rich 哥nb），但是你转念想一想，这笔钱你是否可以花在更有用的地方，而不是虚拟世界中的不足谈起的一件物品</p></li><li><p><strong>影响健康</strong><br>长时间盯着屏幕，眼睛早就已经很难受了，如果你是一名资深的手游玩家，有时候还以为太过于注意，导致你的眼睛离屏幕的距离更近，久而久之视力下降是必然的问题。同时，过度地玩游戏，导致你白天晚上颠倒，经常一玩游戏就是玩到半夜，对肝肾功能也有影响</p></li></ol><hr><h1 id="游戏内的病态"><a href="#游戏内的病态" class="headerlink" title="游戏内的病态"></a>游戏内的病态</h1><p> <strong>#注：这也是我讨厌且鄙视一些游戏的主要原因</strong>    </p><ol><li><p>段位机制<br>这个机制最早被提出来的时候是因为游戏内的核心玩家，或者是高水平玩家互相对比，较量的一种方式。而你现在在任何一款对战类的游戏里面随时可以看到段位的身影，是这个机制本身就有问题吗，还是我们对它的实用出现了偏差？<br><strong>一提到某个游戏，最常见的问题就是：你什么段位</strong><br><strong>恕我直言，现在我觉得紧盯段位玩游戏的人就是傻x(理智看待)</strong><br>这是每个游戏开发商希望看到的，他们想利用这个段位机制的存在，去挑逗玩家的虚荣心，去刺激玩家、捆绑玩家。想要获得更高的段位？在别人面前秀一把？你就得每天不停地在这个游戏里面努力、投入精力去玩  </p><ul><li>也是因为这个东西做鬼才衍生出来了代练，演员</li></ul></li><li><p>氪金  </p><ul><li><p>“腾讯游戏，<del>用心创造快乐</del> 没钱玩尼B” 纵观国内的游戏市场，有多少款游戏是少氪金或者0氪金的呢。有更强大的武器出来了，你需要充钱才能购买，有好康的服饰出来了，你得充钱才能拥有，有箱子可以开了，你需要钱来购买箱子。(???)<br>有的人可能会问：游戏商不赚钱的嘛？搁这儿做公益呢？  </p></li><li><p>那你们玩着同一个游戏，你们技术水平相当，就因为对面那人儿，氪了金，他的武器伤害要比你高，你死了。这能怪谁？  </p></li><li>还有种怪象，你们玩着吃鸡类的游戏，人人都想着在地图里巴不得找个地一直猥琐到决赛圈吃鸡，然后你披着一身亮眼的衣服趴在草丛里，真当对手眼瞎？还是你自己脑残，掩耳盗铃？  </li><li>那氪金是否破坏了一个游戏的公平性？不，只要你我都不氪金，人人都是公平的。那是什么破坏了我的体验？<br><strong>人的攀比、虚荣</strong>  </li></ul></li><li>环境<ul><li>有多少人是因为真正喜欢一款游戏而玩下去的，据我所知，有不少人玩游戏就是为了去带妹、撩骚，或者去享受被带的快感。成年人嘛，多多少少想追求一点刺激，而且我一直搞不明白的就是游戏大厅的存在究竟是为了让玩家更好的交流，还是为了给卖黄片、约炮、诈骗的人一个更好的平台，游戏玩腻了，来轻松♂ 一下  </li><li>祖安队友也是不可避免的存在，多少次我只想好好地打个游戏放松一下，队友祖安掘墓人，对面网易阴阳师(我玩你🐎)</li></ul></li></ol><hr><h1 id="我是如何降低游玩频率的"><a href="#我是如何降低游玩频率的" class="headerlink" title="我是如何降低游玩频率的"></a>我是如何降低游玩频率的</h1><h2 id="不被潮流牵引"><a href="#不被潮流牵引" class="headerlink" title="不被潮流牵引"></a>不被潮流牵引</h2><ol><li>我比较喜欢游戏内每一个角色故事丰满(角色刻画到位)，且背景故事足够科幻，能够吸引我，守望先锋作为现在我时不时就要玩的游戏可谓是再最和我胃口的，没有太多花里胡哨的东西，像我这样又菜又想一直陪着这个游戏的大有人在。市面上的主流游戏，要嘛我不喜欢(了)，要嘛就是没有玩的动力，自然很多游戏对我根本没有太大的吸引力<h2 id="给自己找事儿干"><a href="#给自己找事儿干" class="headerlink" title="给自己找事儿干"></a>给自己找事儿干</h2></li><li><p>思考自己玩游戏的时间，原来我是喜欢一大早就起来，然后打开电脑，刷完没有看完的视频，然后就开始游戏，经常一打就是打一天，饭吃完就继续，或者有时候干脆不吃。久了之后，我意识到游戏好像占据了我太多的时间，但是是确实找不到事儿干才玩的游戏，然后我开始在学校大清早就跑去图书馆，一有空就坐着自习，不得不说解决一个问题获得的满足要比赢一把游戏更放松。  </p></li><li><p>在家的时候就去找一些自己能去实践的小东西，自己去动手解决问题，然后最终实现它。你会发现时间过得无比的快，像半个月前我有的时候周末两天直接忙完，有时想玩会游戏都觉得太晚了，压缩自己能玩游戏的时间，把它留给更有意义的事</p></li></ol><hr><h1 id="BB专区"><a href="#BB专区" class="headerlink" title="BB专区"></a>BB专区</h1><ul><li>玩游戏可以，但是别把玩游戏厉害当作骄傲的资本  </li><li>游戏本身也没有高低贵贱之分，一款游戏只要有人玩就说明这款游戏在某些地方吸引着玩家，也不必去做过多嘲讽  </li><li>该玩玩，该做事做事，不要边做事的时候边玩游戏  </li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>游戏的的确确成为了大部分人生活中的一部分，有空了、闲的没事儿做了都会玩一玩游戏，这篇文章的主旨也不是在阐述玩游戏不好，更多的是从我个人出发，揭示很多时候玩游戏并不是为了真正的乐趣，希望认真看完这篇文章的你有一些想法<br>现在的我早已不把游戏当作不可分割的一部分了，有人找我玩游戏，我想玩就玩，没人找我我就时不时放松一下。感觉每天的时间我可以干更多的事情。作为跳出局的局外人，看待这一切都觉得原来那个沉迷在游戏里的自己是那么幼稚。望每个沉迷在游戏里的有志青年都能早日摆脱游戏的束缚，找到自己的方向</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>近日随记</title>
      <link href="/article/thesedays/"/>
      <url>/article/thesedays/</url>
      
        <content type="html"><![CDATA[<p>放假放了这么久了，还没怎么写过博客，正好最近有一些想写的东西，就一起整合起来写到博客里�?<br>分为以下几个板块:   </p><ul><li>学习方面  </li><li>生活方面  </li><li>感情方面  </li><li><p>其他</p><a id="more"></a><h1 id="3-1-4-4�-…"><a href="#3-1-4-4�-…" class="headerlink" title="3.1~4.4�?…"></a>3.1~4.4�?…</h1><h2 id="1-学习方面"><a href="#1-学习方面" class="headerlink" title="1.学习方面"></a>1.学习方面</h2></li><li><p><u>情况�?</u></p><p>学校在上个月就安排了在线网络学习<br>开了的课程有：<strong>高数、线代、英语、思修、C语言</strong></p></li><li><p><u>自身�?</u></p><p>没得说，放假后是啥样就还是啥样，没有学校里面那种很好的氛围，在家里很懒散，学东西也比较慢，自控力还是不行，羡慕那种哪都能学习�?</p></li><li><p><u>BB:</u></p><p>说实话我们这个专业我感觉挺水的，C语言是上周才开始讲课的，按照学校的安排应该是第一周就会有这门课，感觉网工被当作了<br>计算机学院的孤儿……</p><p>在课程安排里面的大学物理也没开设网课，老师只是在群里面放上了学习资料叫我们自己有兴趣自�?.</p><p>我确实表示怀疑，有理由、有时间开设的课程为什么不能在第一时间上课，据我所知其他专业上网课第一�?.<br>就有大物和C语言</p><p>而且学习平台上放的网课那能叫“网课”？全部是照着课件给你念一遍，我是眼睛有问题还是脑子有问题非得去看那视频？</p></li></ul><hr><h2 id="2-生活方面"><a href="#2-生活方面" class="headerlink" title="2.生活方面"></a>2.生活方面</h2><ul><li><p>球球了，快开学吧，在家的大学生毫无人权，天天看老师直播之余还得抽空去煮个饭（抹泪），我真想哪次我去煮饭去了被点名到回答问题</p></li><li><p>身体一天不如一天（雾）单纯地没有怎么运动，天天宅在家，路都快走不动了</p></li><li><p>没钱！！！在家蹭吃蹭喝，莫得零花钱，我的支付包里面还�?70块钱…想买点东西都只能看着，我太难�?</p></li></ul><hr><h2 id="3-情感方面"><a href="#3-情感方面" class="headerlink" title="3. 情感方面"></a>3. 情感方面</h2><ul><li><p>还算比较顺利，告别了这么久，还一次没有吵过架，她前段时间给我说的分开后没有安全感，一天不找她聊天我也一直在改，确实前段时间有些做得不好，也一直害怕回的消息不够（那啥�?.</p></li><li><p>我觉得目前为止我做得还算是比较满�?(自我感觉良好)，但有些时候确实过分地小心翼翼了，她告诉我自然一点，当然这个我也会慢慢地去适应.</p></li><li><p>在一起了这么多天，感触确实挺大的，有时候不知道她在干嘛，想找她聊天，她却又不空或者没来的及回，有时还是比较失落，这种虚无的感觉让我很是难�?.</p></li><li><p>我觉得面对面一起说话才是最好的交流方式，你知道对方的表情，语气，你知道怎么更好地去回答，但当这一切按照文字的方式传递给对方，就流失了很大一部分的信息，一句话可能产生歧义，解释的时候又因为全是文字的原因不能快速地去表�?</p></li><li><p>毫无保留地说我确实一天比一天想她，是因为我想去见她，而不是一直停留在每天的打字上</p></li></ul><hr><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><ul><li><p>今年年前回家时，告诉我搬家了，新的家还是有点不习惯，住在底楼，有些潮湿和�? ，面积稍微小了一点，不过无所谓，有个能睡觉的地方就可以了。听说爸妈准备再搬，去另外一个小区，现在还在准备装修，等到下次放假的时候回来又是另外一间房子了</p></li><li><p>底楼的好处就是可以打开门直接出去，我们家旁边有很多的野猫，我发现他们后就买了猫粮天天喂它们，每天都有小家伙来陪我还是挺好的，不过最近的猫越来越少了…难受</p></li><li><p>耍的好的基友又被关进监狱�?(他是复读�?)，游戏最近也很少打了，大都是学累了后自己一个人玩玩OW</p></li><li><p>为什么还没开学的消息啊！我想回学校学习！我想实验室了�?</p><p><strong>写到这觉得没啥写的了，想起来4�?7日是我家小可爱的生日~ 再来�?</strong>  </p><ul><li><p>她生日前我觉得我挺憨的，去问送￥%#(代指某种礼物)好不�?…</p><p>我感觉我是合金憨�?</p><p>礼物已经重新帮她选了，现在还在来我家的路�?(预计4�?6号到…)，顺丰给点面子快一点行不行�?5号到吧，然后我还去买了包装纸，准备包装一下再自己发给�?</p><p>刚看了下物流，包装纸预计5号到，球球了，一起来�?</p><p>然后明早再去买其他的东西，希望她拿到的时候不要太�?</p></li></ul></li></ul><hr><p>  <strong>以上就是最近我的记录了，感觉没干啥，但是时间过得飞快，今天(4.4)大部分游戏停服，这难道就是我的转角吗（希望如此），但我已经不求这学期能有很高的绩点了，别挂科就行</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开张啦~</title>
      <link href="/article/Opened/"/>
      <url>/article/Opened/</url>
      
        <content type="html"><![CDATA[<p><strong>终于在今天完成了所有这个网站的前期工作，从明天开始就是正式运行啦</strong></p><p><strong>以后请多多指教</strong></p><blockquote><p>无限进步</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/article/hello-world/"/>
      <url>/article/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World！<br>这是我建立的第一个静态博客鸭，以前听说过hexo，但迫于自身太菜所以就没有去搭建，现在放假闲下来了就搭建好了这个简单的博客<br>想查看更多信息可以阅读完这篇文章，也可以去 <a href="https://codgi.xin/about">关于Codgi的小屋</a> 查看<br><a id="more"></a><br><strong>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check #%&amp;^%#%&amp;$%&amp;^$ <del>好的我知道了</del></strong></p><h2 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h2><h3 id="1-原来从来没有用过markdown-（我就是个菜鸡√）"><a href="#1-原来从来没有用过markdown-（我就是个菜鸡√）" class="headerlink" title="1.原来从来没有用过markdown （我就是个菜鸡√）"></a>1.原来从来没有用过markdown （我就是个菜鸡√）</h3><p>了解markdown，以及熟悉他的用法可能还需要一段时间，也有许多工具可以将Word格式的文章转换为markdown，但我觉得这样好像失去了直接这样书写的乐趣，反正需要用到的语法也不是太多，也有帮助文档可以看，索性以后都用markdow来写我的文章咯~ <del>段落的换行…两个以上空格加回车</del></p><p>oh~逐渐熟练，以后文章里面应该会包含代码以及公式，只有先预习一下了</p><p>More info：<a href="https://blog.csdn.net/witnessai1/article/details/52551362" target="_blank" rel="noopener">语法手册</a></p><h3 id="2-hexo我也是第一次接触它"><a href="#2-hexo我也是第一次接触它" class="headerlink" title="2.hexo我也是第一次接触它"></a>2.hexo我也是第一次接触它</h3><p>这里是hexo的官方网站：<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p><p>简单来说，Hexo是一个快速、简洁、高效的博客框架，使用Markdown（或者其他渲染引擎）解析文章，并利用主题生成静态网页</p><p>这里是Hexo的官方中文文档：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">文档|Hexo</a></p><h3 id="这是我的第二个网站"><a href="#这是我的第二个网站" class="headerlink" title="这是我的第二个网站"></a>这是我的第二个网站</h3><p>第一个使用的是Wordpress，里面的主题始终让我不满意，有很多时候需要去改主题的源代码，想加一个插件又怕跟主题不能兼容<br>百般无奈，新开一个，这里就记录学习、思考，那边记录生活，琐事。<del>免得把狗骗进来杀</del>  </p><h3 id="More："><a href="#More：" class="headerlink" title="More："></a>More：</h3><p>  博客所使用的主题：<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Melody</a><br>  主题作者的博客：<a href="https://molunerfinn.com/" target="_blank" rel="noopener">MARKSZ</a><br>  同时感谢<a href="https://sheey.moe" target="_blank" rel="noopener">Sheey</a>的帮助和解答</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
